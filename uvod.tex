\chap Úvod

Přepínače založené na bázy ethernetu, které splňují industriální teplotní rozsahy se téměř v dnešní době nevyrábějí.
A moduly splňující tyto rozsahy, které mají integrované MII rozhraní, pro připojení fyzické vrstvy, jsou v jiných cenových kategoriích.
Proto tato práce přináší možnost připojení k ethernetového přepínače z pomocí USB sběrnice. A ovladače pro tento přepínač založené na operačím systému Linux.

Tato práce se zabívá portací operačního systému Linux na modul Colibri T20, který má integrované hostitelské USB zařízení a spňuje industriální teplotní rozsahy.
Dálé se zabívá implementací ovladače do operačního systému Linux pro zařízení na bázy přepínacího obvodu s možností inicializace za běhu zařízení do současné verze Linuxového jádra s pokusem zařadit ovladač do hlavní větve Linuxového jádra.
Přepínač je založen na přepínacím obvodu 88E6065 vyvíjený firmou Marvell, který je připojen USB kontrolérem AX88772b vyraběný firmou Asix.
Obě tyto zařízení též splňují industriální rozsahy teplot.

\medskip

Tato práce v první kapitole \ref[pouztech] popisuje použitou technologii jako je sběrnice USB \ref[USB] a  MII rozhraní \ref[MII].
U nichž se dozvíme jak tyto technologie fungují a jak jsou definovány.
Dále se dozvíme jaká mají omezení a jak vypadá jejich hgarwarová implemntace.
Též se dozvíme o rozšíření rozhraní MII \ref[RMIIsub].
Tato kapitole též věnuje popisu mechanismus ovladačů a příslušných Linuxový subsystém \ref[LINUXsub].
Konkrétně část síťového subsystémui, usb subsystému a subsystému přepínače.

V kapitole Použitý Hardware \ref[pouzhw] se dozvíme o zvoleném modulu Colibri T20 a vyrobené desce ethernetového přepínače.
Konrétně čipů použitých na této desce, jako je USB kontrolér AX88772b a přepínací obvod 88E6065.

V další kapitole zvaná Implementace \ref[impl] popisuje nahraní nového Linuxového jádra a postup při oživování desky.
Dále pak popisuje architektonický návrh ovladače pro operační systém Linux.
A následuje sekce o ipmlementaci tohoto návrhu ovladače pro přepínací obvod.

V poslední kapitole, kterou je Testování \ref[TEST] je popisáno jak probíhá nastavení přepínacího obvodu.
Dále se popisují spuštěné testy ovladače přepínacího obvodu.
a nakonec se vyhodnocutí výsledky těchto testů.

\label[pouztech]

\chap Použité technologie

Tato kapitola je rozebírána použitá technologie.
V první části je rozebrána sběrnice USB \ref[USB].
Další významnou sekcí je rozhraní Media Independent Interface, který předpokládá znalost modelu OSI, který je tu též uveden.
Ke konci této kapitoly bylo rozepsáno jak vypadájí ovladače v linuxu a tvář linuxového subsystému Distributed Switch Architecture a k němu přilehlé subsystémy.

%LDD3 pekny popis zarizeni http://www.makelinux.net/ldd3/?u=chp-13-sect-4
%MAC podporuje 802.3 a 802.3u MAC funkce, jako je prijem a odeslani ramce, kontrolu CRC, duplex mode, forwarding, flow-control, detekce kolizi atd.

%\label[ISO]
%\sec Model ISO/OSI
%Model ISO/OSI je konceptuální model, který charakterizuje komunikačních sítích. Rozdělaná do vrstev.

\label[USB]

\sec Univerzální Sériová Sběrnice

Univerzální Sériová Sběrnice je technický standard vyvíjený od roku 1994 pro připojení periferií k počítači.
Tato sběrnice měla nahradit pomalé sběrnice (jako jsou seriová linka, paralelní port, PS2 a mnohé další) jednou sběrnicí \cite[LDD3].
V dnešní době USB umožňuje přenášet velké množství dat s rychlostí až 640 MB/s u USB zařízení verze 3.0.
Díky tomu se použití USB rozšířilo a nyní podporuje skoro každý druh zařízení, která umožňují přenašet video, audio a dokonce i ethernetové rámce a pakety.
Podporovaná zařízení jsou rozdělena do tříd z důvodu sjednocení funkcionality a chovaní zařízení.
Nejznámějšími třídami jsou HID, Printer a Mass Storage, které jsou více popsány ve vývojářské dokumentaci \ref[USB].
Toto sjednocené chování má za důsledek společných ovladačů, která tato zařízení mohou využívat.
Problém s některými druhy zařízení je takový, že je nejde do daných tříd zařadit, popřípadě mají rozšířené chování a potřebují speciální přístup.

\secc Rysy USB zařízení

USB je deterministická sběrnice (Master/Slave), která podporuje detekci připojeného zařízení za běhu (plug\&play) a následnou automatickou konfiguraci (hotswap).
USB síť se zkládá ze třech druhů zařízení \cite[USB]:
\begitems
*Hostitel -- je zařízení typu Master a je jako jediný v systému, řídí komunikaci a obvykle integruje rozbočovač označen jako kořenový.
Přiděluje zařízením unikátní adresu v síti.
*Rozbočovač -- distribuuje datové toky a identifikuje připojení a odpojení dalších zařízení.
*Zařízení -- Pojmem zařízení je míňeno koncové zařízení s požadovanou funkcionalitou, které odpovídá na kontrolní zprávy.
\enditems

USB je asymetrická sběrnice s jedním zařízením typu Master, která spíše vypadá jako strom složený z linek bod-bod.
Přičemž USB huby vytvářejí jednotlivé uzly tohoto stromu a zařízení tvoří jejich listy.
Linky USB sběrnice jsou 4 vodičové obsahující diferenciální pár datových linek, napěťový a zemnící vodič, které připojují zařízení a USB huby.
USB umožňuje připojit až 127 zařízení v rámci jedné USB sítě o hloubce maximálně pěti rozbočovaču.


USB je asymetrická sběrnice, kterou lze popsat jako strom složený z linek bod-bod.
USB huby vytvářejí jednotlivé uzly tohoto stromu a zařízení tvoří jejich listy.
USB umožňuje připojit až 127 zařízení v rámci jedné USB sítě o hloubce maximálně pěti rozbočovačů, tak jak můžeme vidět na obrázku \ref[USBhub].

\medskip
\clabel[USBhub]{USB tier.}
\picw=13cm \cinspic images/technet.microsoft.com.jpg
\caption/f Obrázek popisuje jak lze USB zapojit \cite[MSTECH].
\medskip

Linky USB sběrnice jsou 4 vodičové vedení obsahující diferenciální pár datových linek, napěťový a zemnící vodič, která připojují zařízení a USB huby.

Díky tomu USB umožňuje jednoduchý mechanismus detekce a enumerace, neboli průběhu konfigurace (více informací níže \ref[USBkom]), za běhu systému, který je řízen a konfigurován automaticky hostitelem.


\label[USBkom]

\secc Komunikace

USB komunikace je založena na logických kanálech tzv. rourách. Každému výstupnímu kanálu by měl odpovídat právě jeden vstupní.
Koncový bod obsahuje rouru s definovaným směrem.

USB muže mít maximalně 30 koncových bodů. Koncový bod je roura s definovaným směrem.
Tyto koncové body jsou inicializovány v průběhu enumarace USB zařízení, které probíhá po kontrolní rouře označené číslem 0, kterou mají všechna zařízení společnou.
Každý koncový bod obsahuje rouru s předem definovaným typem přenosu:

\begitems
*Řídící -- Obousměrná roura sloužící ke konfiguraci zařízení. Každé zařízení disponuje tímto druhem roury. Má rezervovanou určitou přenosovou kapacitu.
*Izochronní - Jednosměrná roura sloužící ke stálému přenosu většího objemu dat. Má garantovanou latenci, přenos však není spolehlivý. Tento typ roury je vhodný pro audio a video.
*Přerušovací - Jednosměrná roura sloužící pro časté přenosy malého množství dat. Má garantovanou šířku pásma. A přenos dat je spolehlivý. V případě chyby se přenos opakuje.
*Blokový - Jednosměrná roura sloužící k přenosu velkého množství dat. Nemá rezervovanou žádnou přenosovou kapacitu ani dobu odezvy. Komunikace po této rouře je spolehlivá a v případě chyby se přenos opakuje.
\enditems

Enumerace je posloupnost standardizovaných příkazů, kterou započal hostitel.
V průběhu enumerace se předávají deskriptory, které obsahují důležité informace o zařízení.
Hierarchiji deskriptorů můžeme vidět na obrázku \ref[USBhier].

\medskip
\clabel[USBhier]{Hierarchije USB deskriptorů.}
\picw=13cm \cinspic images/IMG019.pdf
\caption/f Obrázek popisuje jak lze USB zapojit \cite[LUSB].
\medskip


\begitems
*Dekriptor zařízení -- Obsahuje informace jako je ID vyrobce a produktu.
Též obsahuje informace o třídě a maximalní delku paketů, které může roura 0 přijmout.
*Konfigurační deskriptor -- Oznamují jak mají být napájeni, maximální proud, počet rozhraní. Těchto dekriptorů může být více.
*Deskriptor rozhraní -- Tento dekriptor informuje o funkcionalitě celého celku jako je třídá koncových zařízení a počet koncových bodů.
*Deskriptor koncového bodu --Používá se k přesnémuj popisu koncového bodu.
*Textový dekriptor -- Tento dekriptor přenáší pouze čitelné informace o zařízeních kódované v Unicodu
\enditems

Na základě informací v deskriptorech se operační systém rozhoduje, který druh ovladače přiřádí danému druhu zařízení.


\medskip \medskip \medskip \medskip

\label[MII]

\sec Media Independent Interface

Media Independent Interface (MII) je typ rozhraní, který umožňuje připojení nezávislé na procesoru a fyzickém médiu.
Tento typ rozhraní je specifikován standardem IEEE 802.3, který je popsán v kapitole 22 \cite[IEEE8023].
MII propojuje dvě vrstvy modelu ISO/OSI, a to vrstvu spojovou, konkrétně její část Media Access Constroll (MAC),
\fnote{MAC je popsána standardem IEEE 802.2001. Stará se o přijímaní a odesílání rámců(přístup k mediu), ochranu proti chybám}
s vrstvou fyzickou (PHY)
\fnote{PHY převádí bitový stream na signál a definuje jeho doručení.}.
MII rozhraní podporuje dva datové toky - 10~Mb/s a 100~Mb/s.
Na obou datových tocích je funkcionalita MII identická, liší se pouze v nominální frekvenci hodin.
Vyšší rychlosti přenosu je možno dosáhnout změnou rozhraní na Gigabite Media Independent Interface, které podporuje rychlost až 1~Gb/s.

\medskip
\clabel[MIItoISO]{Spojitost mezi MII a OSI/OSI}
\picw=16cm \cinspic images/802_iso.pdf
\caption/f Obrázek popisuje spojitost mezi rozhraním MII, modelem OSO/OSI a modelem IEEE 802.3 CSMA/CD LAN \cite[IEEE8023].
\medskip

Na obrázku \ref[MIItoISO] je vidět připojení MII na Reconsiliation Sublayer (RS) a PCS nebo PLS.%rozepsat zkratky
RS je podvrstva, která mapuje signály z MII na MAC/PLS obsluhu.
PLS a PCS jsou vrstvy, které se starají o kódování a dekódování signálů.
Konkrétní mapování MII signálů znázorňuje obrázek \ref[RStoMII].

\medskip
\clabel[RStoMII]{Mapování signálů RS na MII}
\picw=15cm \cinspic images/802_rs.pdf
\caption/f Obrázek popisuje, jak RS mapuje signály mezi MII a PLS. Také lze vidět připojení STA \cite[IEEE8023].
\medskip

Jak můžeme vidět na obrázku \ref[RStoMII], fyzické rozhraní MII se skládá ze dvou druhů sběrnic, a to datové \ref[MIIdat] a menežovací (STA) \ref[MDIOs].
STA může být připojeno až k 32 fyzickým jednotkám. které obsluhuje.

\label[MIIdat]

\secc Datová část MII rozhraní

Datová část MII disponuje několika druhy signálů, které lze vidět na pravé straně obrázku \ref[RStoMII]. 
Tyto signály jsou připojeny k přemapovací vrstvě RS.
Druhy datových signálů:

\begitems
*TX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech TX\_EN, TXD a TX\_ER.
Zdrojem signálu TX\_CLK je PHY. 
Frekvence tohoto signálu by měla být 20\% z nominální hodnoty přenosu dat +- 100ppm. %TODO plus minus
*RX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech RX\_DV, RXD a RX\_ER.
Zdrojem signálu RX\_CLK je RS. %XXX kouknout na manuál
RX\_CLK může odvodit referenční hodnotu z přijímaných dat nebo z nominální hodnoty jako u signálu pinu TX\_CLK.
*TX\_EN -- pin vysílající signál, který indikuje, že je RS připravena odesílat data.
*TDX -- čtveřice datových pinů vysílající signál (TDX[3:0]) ovládaná podvrstvou RS, která přenáší data synchronně na základě signálu z pinu TX\_CLK. 
TDX[0]  přenáší nejméně významný bit.
Pokud je TX\_EN fyzicky odpojen, TDX nemá žádný efekt na činnost PHY.
*TX\_ER -- pin vysílající signál řízený podvrstvou RS, který indikuje. že PHY začala vysílat jeden či více symbolů, které nejsou součástí dat, nebo že předčasně došlo k přerušení rámce.
Signál na tomto  pinu je synchronní s hodinovým signálem z pinu TX\_CLK.
*RX\_DV -- pin vysílající signál, který značí, že přijatá data jsou validní. Tento signál je řízen PHY a je synchronní se signálem z pinu RX\_CLK.
*RXD -- čtveřice datových pinů vysílající signál (RDX[3:0]) ovládaná vrstvou PHY, která slouží k přenosu dat z vrstvy PHY do podvrstvy RS.
RXD[0] přenáší nejméně významný bit.
*RX\_ER -- pin vysílající signál řízený vrstvou PHY, který indikuje, že nastala chyba detekovaná v průběhu přijímání rámce.
Pokud je pin RX\_DV odpojen, nemá žadný vliv na činnost podvrstvy RS.
*CRS -- pin vysílající signál indikující, zda je příjemce nebo odesílatel zaneprázdněn, nebo je ve stavu idle.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování. %XXX asi smazat
*COL -- pin vysílající signál, který je vyvolán vrstvou PHY, indikující kolize, které nastaly na médiu.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování.
\enditems
%Reprezentuje pokud josu data na odeslani nebo prijeti.

\medskip
\clabel[transiotionMII]{Komunikace po MII bez kolize.}
\picw=15cm \cinspic images/802_miicom.pdf
\caption/f Obrázek znázorňuje, jak vypadá bezchybná komunikace po MII \cite[IEEE8023].
\medskip

Na obrázku \ref[transiotionMII] lze vidět, jak vypadá komunikace po MII rozhraní.
Pin TX\_CLK přenáší referenční hodinový signál, který se pravidelně mění.
Při odesílání dat se nahodí signál z pinu TX\_EN, který začne odesílat preambuly.
Přenos těchto dat je popsán níže.
S přijímaním signálu začne být příjemce zaneprázdněn, a proto nahodí signál z pinu CRS.
Celá komunikace probíhá pouze jedním směrem a neobsahuje žádnou chybu, jak je možno vidět ze signálu na pinu COL.

Rámec dat, který je přenášen po MII rozhraní, je doplněn o hlavičky a patičky popsáné formátem:

\begtt
<vstupní rámec><preambule><sdf><data><edf>
\endtt

Kde jednotlivé položky mají následující význam:

\begitems
*vstupní rámec -- je perioda mezi rámci, při které nesmí dojít k žádné činnosti na rozhraní MII.
Tato perioda není přesně specifikována.
*preambule -- je definovaná posloupnost dat, která se skládá ze 7 oktetů (bytů) a je přenášena ve formě pravidelného střídání jedniček a nul.
*sdf -- oktet, který oznamuje začátek rámce.
*data -- značí přenesená data.
*efd -- konec rámce, který provede shození signálu na pinu TX\_EN.
\enditems

Rámce jsou přenášeny tak, že oktet je rozdělen na dvě poloviny tzv. nibbles.
Tyto poloviny jsou odeslány po datových linkách TXD nebo RXD.
Příklad odeslání oktetu po pinech TDX je znázorněn na obrázku níže \ref[NIBBLE].

\medskip
\clabel[NIBBLE]{Rozdělení oktetu po datových pinech}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_nibble.pdf
\caption/f Obrázek popisuje, jak je rozdělen byte, který je následně odeslán po pinech TDX \cite[IEEE8023].
\medskip


\label[MDIOs]

\secc Menežovací rozhraní a příslušný registrový prostor

Menežovací část sběrnice, která se značí STA, se používá k nastavování a čtení hodnot mezi vrstvamy MAC a PHY.
Toto rozhraní je dvoulinkové sériové a obsahuje dva datové vodiče:
\begitems
*MDC -- pin vysílající signál určující časovou základnu pro signál vysílaný pinem MDIO.
Signál z pinu MDC je aperiodický, nemá žádnou minimální ani maximální frekvenci, měl by se však pohybovat v rozmezí od 160~ns do 400~ns.
*MDIO -- pin vysílající signál. Tento pin je vstupně výstupní a jsou po něm posílány signály oběma směry.
Je tvořen třístavovým obvodem mezi vrstvami PHY a STA.
Pin se používá k přenosu kontrolních zpráv mezi zařizeními.
Přenos je řízen z vrstvy PHY.
Signál z pinu MDIO je synchronizovaný se signálem z pinu MDC.
\enditems

Formát menežovacích rámců je popsán v tabulce \ref[MDIOframe].
Data z této tabulky jsou odesílána po pinu MDIO ve směru z levé strany tabulky do pravé.

\midinsert \clabel[MDIOframe]{Formát menežovacích rámců.}
\ctable{lllllllll}{
 \hfil            & PRE & ST & OP & PHYAD & REGAD & TA & DATA & IDLE \crl \tskip4pt
          čtení   & 1...1 & 01 & 10 & AAAAA & RRRRR & Z0 & D...D & Z \cr
          zápis   & 1...1 & 01 & 01 & AAAAA & RRRRR & 10 & D...D & Z \cr
}
\caption/t Tabulka popisuje formát menežovacích zpráv \cite[IEEE8023] (Tabulka 22-12).
\endinsert

V tabulce \ref[MDIOframe] lze vidět hodnotu preambule (PRE), což je posloupnost 32 bitů skládajících se z hodnot logických jedniček.
Preambule slouží k synchronizaci signálu z pinu MDC.
Začátek rámce je označený ST a má hodnotu 01.
Poté jsou odesílána data popisující operační kód (OP), která určují druh operace: čtení nebo zápis.
PHYAD je zkratka pro fyzickou adresu zařízení o délce 5 bitů.
Tím dokážeme naadresovat až 32 zařízení.
První bit adresy je nejvíce významný.
Další položkou je adresa registru (REGAD) číslovaná podle níže uvedených registrů.
Dalším blokem je TA.
Při operaci čtení hodnota TA obsahuje stav vysoké impedance (Z) sloužící k prohození příjemce za odesílatele, jak lze vidět na obrázku \ref[mdioread].
Prohození  probíhá z důvodu požadavku odpovědi na operaci čtení tj. hodnoty z registru.
Při operaci zápis tato změna není potřeba a stav vysoké impedance je nahrazen logickou jedničkou.
Odesílaná data mají 16 bitová hodnotu, tedy stejnou jako je velikost registrů.

\medskip
\clabel[mdioread]{Čtení registru po STA.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_miimdio.pdf
\caption/f Obrázek ukazuje čtení z registru při komunikaci po sériové lince STA \cite[IEEE8023].
\medskip

Operacemi čtení a zápis může vrstva MAC přistupovat k registrovému prostrou na PHY, který tak může měnit.
Část tohoto registrového prostoru je definována standardem 802.3.
Registrový prostor obsahuje dva základní sety registrů -- kontrolní a stavový.
Všechny PHY, které podporují MII, by měly používat právě tuto sadu registrů \ref[miireg].


\medskip
\clabel[miireg]{Registry STA rozhraní.}
\picw=15cm \cinspic images/802_miireg.pdf
\caption/f Obrázek popisující registry STA rozhraní. Obrázek je převzat z~\cite[IEEE8023].
\medskip


Tyto registry specifikují základní vlastnosti PHY pro MII rozhraní o rychlostech 100~Mb/s a 1~Gb/s.
Registry 2 -- 14 jsou částí rozšířeného registrového prostoru \cite[IEEE8023] (22.2.4).
Bližší popis stavového a kontrolního registru je uveden v příloze \ref[MIIcntr] a \ref[MIIstat].


% Ne do DP
%\sec GMII

%The Gigabit Media Independent Interface (GMII) is similar to the MII. The GMII uses the MII management interface and register set specified in 22.2.4. These common elements of operation allow Station Management to determine PHY capabilities for any supported speed of operation and configure the station based on those capabilities. In a station supporting both MII and GMII operation, configuration of the station would include enabling either the MII or GMII operation as appropriate for the data rate of the selected PHY. Most of the MII and GMII signals use the same names, but the width of the RXD and TXD data bundles and the semantics of the associated control signals differ between MII and GMII operation. The GMII transmit path clocking also differs significantly from MII clocking. MII operation of these signals and clocks is specified within Clause 22 and GMII operation is specified within Clause 35.
%GMII obsahuje 3ti zakladni registr Extended status reg(15)

\label[RMIIsub]

\secc Reduce Media Independent Interface

Reduce Media Independent Interface (RMII) je obdoba rozhraní MII, která má ale snížený počet pinů z 16 na 8 \cite[RMII].
RMII přidává pouze reconciliation layer (RS), a to buď jako novou, která je připojena za stávající RS, nebo jako náhradu aktualní RS v MII \cite[RMIIcon].

Rozšířenou RS lze vidět na obrázku \ref[RMIIRS].

\medskip
\clabel[RMIIRS]{Rozšíření MII o další RS.}
\picw=15cm \cinspic images/rmiirs.pdf
\caption/f Obrázek, který znázorňuje rozšíření MII o další vrstvu RS.  Obrázek je převzat z~\cite[RMII].
\medskip

RMII používá stejné menežovací rozhraní jako MII definované standardem IEEE 802.3u \cite[IEEE8023], který je popsán v sekci \ref[MDIOs].

Hlavními rozdíly RMII oproti MII jsou datové piny TXD a RXD. které jsou v RMII pouze 2 bity široké.
Dále signály z pinů COL a CRS jsou zde sjednoceny do jednoho signálu na pinu CRS\_DV.
Dalším rozdílem je detekce kolizí, která je na vrstvě MAC provedena jako logický součin signálů TX\_EN a CRS\_DV.
Zdrojem hodinového signálu je vrstva MAC nebo je generován externími hodinami.


% TODO
%\sec linux

%\sec info kernel

%\sec loading proces

%\sec disribuce

%\secc openwrt

\medskip \medskip \medskip \medskip

\label[LINUXsub]

\sec Subsystém operačního systému Linux

Tato kapitola obsahuje informace o tom, co to je ovladač, a dále popisuje základní stavební prvky naimplementováné v operačním systému Linux: device, mii\_bus, net\_device, DSA a sysfs.

\secc Co je to ovladač

Ovladač je část programu (algoritmu), která spravuje nebo kontroluje určité zařízení připojené k počítači.
Ovladače vytvářejí softwarové rozhraní pro hardwarové zařízení, která umožňují operačnímu systému ovládat tento hardware, aniž by uživatel věděl, jak přesně funguje \cite[LDD3].

\secc device

Každé zařízení naimplementované na nejnižší úrovni je v operačním systému Linux reprezentováno instancí struktury {\em device}.
Struktura device obsahuje informace o tom, co zařízení potřebuje, aby správně fungovalo v systému.
Mnoho subsystémů uchovává informace o struktuře device a tyto informace využívají k dalším procesům.
V dnešní době je velmi obtížné nalézt zařízení, které je reprezentováno pouze struktorou {\em device}.
Místo toho  některé instance v struktuře {\em device}, jako je kobj, obecně implementují výše reprezentovaná zařízení \ref[DEV]. %XXX divny
\fnote{Popis datové struktury {\em device} lze nalézt na \url{http://lxr.free-electrons.com/source/include/linux/device.h\#L730}}.

\secc mii bus

{\em Struct mii\_bus} je struktura, která reprezentuje MII rozhraní a umožňuje přístup k registrům popsaným v \ref[miireg].

\label[DSA]

\secc Distributed Switch Architecture

Distributed Switch Architecture (DSA) je rozhraní pro menežování hardwarových přepínačů \cite[DSA].
%Obsahuje MII menežovací registry, příkazy pro nastavení přepínače a formát ethernetových hlaviček, který signalizuje na kterém portu byl paket přijat nebo ktery se hodlá odeslat 
Tento subsystém podporuje přepínače, které jsou připojeny způsobem zobrazeným na obrázku \ref[DSAcon].

\medskip
\clabel[DSAcon]{Připojení DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Tento subsystém reprezentující přepínače interpretuje každý port jako oddělené síťové rozhraní \ref[NETDEV].
Nastavování přepínače, jako je stav portů a menežování MII rozhraní, je provedeno na základě rozhraní ethtool \fnote{Ethtool je standardní utilita Linuxu pro ovládání a podporu ovladačů a zařízení.}.

Subsystém DSA podporuje i propojení mezi přepínači tak, jak je možno vidět na obrázku \ref[DSAcon2].
Takto propojené přepínače lze ovládat skrz MII rozhraní.

\medskip
\clabel[DSAcon2]{Připojení více přepínačů DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon2.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Na obrázku \ref[umlDSA] je diagram tříd důležitých struktur v subsystému DSA, které jsou nezbytné pro funkčnost subsystému.

\medskip
\clabel[umlDSA]{Diagram tříd DSA subsystému.}
\picw=15cm \cinspic images/dsa_uml.pdf
\caption/f Na obrázku můžeme vidět popis vybraných datových struktur.
\medskip

Na tomto obrázku jsou zvýrazněny struktury {\em mii\_bus}, {\em net\_device} a {\em dsa\_platform\_data}.
Tyto struktury DSA subsystém nevytváří, a proto je potřeba tyto struktury předat subsystému.

%XXX upravit aby to bylo více vypovídající
Subsystém DSA je reprezentován strukturou {\em dsa\_switch\_tree}, která obsahuje odkazy na struktury:
\begitems
*dsa\_platform\_data -- tato struktura informuje o tom, jaká zařízení jsou připojená ke kořenovému přepínači.
Také obsahuju strukturu {\em dsa\_chip\_data} popsanou níže.
*net\_device -- tato struktura odkazuje na hlavní síťové zařízení \ref[NETDEV].
*dsa\_switch -- obsahuje data pro jednotlivé přepínače popsané níže.
\enditems

Struktura {\em dsa\_switch} nesoucí data o připojeném přepínači obsahuje následnující data:
\begitems
*dsa\_switch\_tree -- je odkaz na rodičovskou strukturu.
*dsa\_chip\_data -- struktura obsahující informace o fyzickém přepínači -- kolik má portů a jaké jsou jejich názvy.
Navíc obsahuje informace o device tree \fnote{Device tree je popis hardwarového zařízení v kódu.}.
*device -- je odkaz na hostovské zařízení, které se právě využívá.
*dsa\_switch\_driver -- struktura popisující ovladač přepínačů, obsahuje funkce na menežování připojeného přepínače.
*mii\_bus -- je ovladač MII sběrnice.
*net\_device -- je odkaz na síťové zařízení \ref[NETDEV] reprezentující port zařízení.
\enditems


\label[NETDEV]

\secc net device

Struktura {\em net\_device } popisuje síťové rozhraní \cite[ULNI].
Síťové rozhraní může přijímat a vysílat velké množství dat, a proto je implementace podobná diskovým zařízením \cite[LDD3].
Síťová zařízení přijímají data asynchronně a ukládájí je do vyrovnávací paměti.

V linuxovém jádře je síťový subsystém naimplementován tak, že je na protokolu nezávislý.


JEdnotlivé složky struktury {\em net\_device } může být klasifikována do několika kategorií:
\begitems
*Konfigurace -- něterá konfigurace je dána Linuxovým jádrem a nějaké jsou možné nastavit programamy z uživatelského rozhraní jako je ifconfig a ip.
*Statistiky -- Statistyky jako počet odeslaných paketů a paketů přiajtých, popsané v struktuře, která se jmenuje priv.
*Stav zařízení
*Menežování přenosu -- Nastavení kvality služeb (QoS).
*Odkazy na funkce -- Tyto ukazatele jsou implemntovány ovladači zařízeních. Obsahují funkce jako je nahození portů, shození portů, nastavení adres a mnohé další popsané v dokumentaci Linuxového jádra nebo \cite[ULNI].
\enditems


\label[USBst]

\secc usb ovladač

Linuxové jádro podporuje dva druhy USB zařízení -- ovladače na hostovském systému a ovladače na zařízení \cite[LDD3].
USB ovladač na hostovském systému pracuje na systému, ke kterému je USB zařizení připojeno.
Ovladač na zařízení, neboli \"USB gadget drivers\" , je připojojen k hostovskému systému a chová se jako hostovská stanice připojena přes USB. %TODO opravit vetu
Na obrázku níže můžeme vidět USB hierarchii, kde USB může existovat v několika různých subsystémech (net, block, char ...).
USB jádro implementuje rozhraní pro USB ovladače, které chtějí kontrolovat hardware a přistupovat k němu.

Koncové body USB jsou popsány v jádře Linuxu strukturou {\em usb\_host\_endpoint}.
Tato struktura obsahuje informace o reálném koncovém bodu ve struktuře {\em usb\_endpoint\_descriptor}.
Struktura {\em usb\_endpoint\_descriptor} popisuje data pomocí přijatých deskriptorů.

\medskip
\clabel[USBMAP]{Hierarchie USB.}
\picw=15cm \cinspic images/usbendpmap.pdf
\caption/f Na obrázku lze vyčíst hierarchii USB prvků. Obrázek převzat z \cite[LDD3]. %TODO popisek
\medskip


USB rozhraní je složeno z několika koncových bodů, které tvoří jedno logické připojení jako je napřiklad myš, klávesnice, video atd.
Některá USB zařízení však mohou mít více rozhraní.
Například USB repoduktory mohou mít dvě rozhraní, jako je USB klávesnice pro tlačítka reproduktoru a USB audio pro jeho zvuk \cite[LDD3].%TODO presunout nahoru
Linuxové jádro používá pro každé rozhraní právě jeden hardwarový ovladač.
Toto rozhraní je popsáno strukturou {\em usb\_interface}.
Tato struktura je to, co USB jádro předává USB ovladačům.
Každé zařízení je vázáno konfigurací, které je předáváno v deskriptorech.
Linuxové jádro popisuje konfigurace ve struktuře {\em usb\_host\_config} a celé USB zařízení strukturou {\em usb\_device}.
Jedno USB zařízení však může mít konfigurací více.
Konfigurace se mohou v průběhu práce zařízení měnit.
Linuxové jádro ale nemůže obsluhovat více konfigurací v jeden čas.


Ovladače USB zařízení  obyčejně přepisují data z {\em usb\_interaface} do {\em usb\_device}.
Samotné struktury {\em usb\_device} a {\em usb\_interface} jsou zobrazeny v sysfs\ref[SYSFS] jako jednotlivé soubory.
Ukázková cesta ke struktuře {\em usb\_device} reprezentována pomocí sysfs \ref[SYSFS] může vypadat následovně:

\begtt  /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1  \endtt

K výše uvedené cestě k USB zařízení je na řádku níže zvýrazněno USB rozhraní reprezentováno strukturou {\em usb\_interface}.
Tato struktura je pojmenována podle formátu root\_hub-hub\_port:config.interface (pro hlubší stromy je schéma root\_hub-hub\_port-hub\_port:config.interface):

\begtt /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1/2-1:1.0 \endtt

Pro komunikaci se všemi USB zařízeními používá Linuxové jádro USB request block (urb).
Urb je asynchronní typ komunikace, která se používá k posílaní a příjmu dat pro specifický koncový bod USB a specifické USB zařízení.

\label[USBNET]

\secc usbnet

Usbnet je subsystém Linuxového jádra, který umožňuje ovládat USB--síťová zařízení jako je ethernet, DSL, IDSN atd. \ref[USBNET]
Usbnet je obecná USB--síťová nadstavba, která pracuje na různých rychlostech a nad různými protokoly.

Na obrázku níže lze vidět uml diagram důležitých struktur v ovladači AX88772b \ref[umlASIX].

\medskip
\clabel[umlASIX]{Diagram tříd ovladače AX88772b.}
\picw=15cm \cinspic images/driver_asix.pdf
\caption/f Na obrázku můžeme vidět popis vybraných datových struktur v subsystému usbnet.
\medskip

Na obrázku \ref[umlASIX] je znázorněn usbnet obsahuje informace o:
\begitems
*net\_device -- zařízení reprezentující síťové rozhraní
*driver\_info -- rozhraní pro ovladač usbnet zařízení
*usb\_device -- struktura reprezentující zařízení USB
\enditems

\label[SYSFS]

\secc System Filesystem

System FileSystem (Sysfs) je charakteristika Linuxového jádra od verze 2.6, která umožňuje jadernému kódu exportovat informace do uživatelského prostoru za použití paměti VFS\ref[SYSFS].
Hlavním učelem je reprezentovat objekty, jejich atributy a jejich vztahy navzájem.
Většina atributů je reprezentována souborem, který je ve formátu ASCII a obsahuje pouze jednu hodnotu.
Sysfs poskytuje dvě složky:

\begitems
*kernel programming interface -- slouží k exportování a importování položek (viz níže) skrz sysfs do jádra
*user interface -- slouží k zobrazení a manipulaci s těmito položkami (viz níže), které mapuje zpět na objekty v jádře
\enditems

Mapování objektů a atributů můžeme vidět v \ref[SYSFSmap].

\midinsert \clabel[SYSFSmap]{Mapováni objektů a atributů v sysfs.}
\ctable{ll}{
 \hfil  Interní   & Externí  \crl \tskip4pt
        Jaderné objekty    & Složky  \cr
        Atributy objektů     & Soubory  \cr
        Vazby mezi objekty   & Symbolické odkazy  \cr
}
\caption/t  Tabulka převzata z \cite[SYSFS].
\endinsert

V systému lze vidět tato zařízení ve složce {\em /sys/ }.
Složka /sys/ může vypadat následovně:
\begtt
    /sys/
    |-- block
    |-- bus
    |-- class
    |-- devices
    |-- firmware
    |-- module
    ‘-- power
\endtt

Sysfs je reprezentováno v Linuxovém jádře jako struktura {\em kobj}, která obsahuje tři druhy obslužného volání -- na zápis, čtení a na uvolňení.

\label[pouzhw]


\chap Použitý hardware


%TODO neajky uvod

\label[T20]

\sec Colibri T20

Colibri T20, vyráběný firnou Toradex \ref[TODADEX], je počítačový modul postaven na základě NVIDIA Tegra 2 vestavěném systému na čipu \cite[SOC].
%Popsat modul vice TODO 
Čip obsahuje periferie popsané na blokovém diagramu na obrázku \ref[SOC].

\medskip
\clabel[SOC]{Colibri T20 blokový diagram.}
\picw=15cm \cinspic images/soc.pdf
\caption/f Obrázek popisuje části integrované na modulu Colibri T20 \cite[SOC].
\medskip

Toradex dodává k tomuto modulu podporu BSP pro Linuxové jádro 3.1.

\sec NVIDIA Tegra 2

Systém na čipu NVIDIA Tegra 2 je založen na dvoujádrovém procesoru Cortex A9 se symetrickým procesorovým jádrem od firmy ARM s frekvencí procesoru okolo 1~GHz \cite[TEGRA2].
Jelikož se jedná o systém na čipu, obsahuje tento čip mnoho bloků, jako je například Audio/Video rekordér, grafický procesor s podporou 2D rendrovaní a 3D pixel a vektor shadrem.

Procesor A9 má 32-bitovou RISC
\fnote{Architektura RISC označuje procesory s redukovanou instrukční sadou \cite[RISC].}
architekturu vyvíjenou společností ARM Holding věnující se vývoji procesorových jader.
Tento procesor podporuje out--of--order a spekulativní provádění instrukcí.
Má plnou podporu koherence pamětí pro symetrické procesory.
Procesor A9 dosahuje vysokého grafického i výpočetního výkonu, viz \cite[BENCH].
Procesor též obsahuje jednotku pro výpočty s plovoucí řádovou čárkou.

Popis jádra NVIDIA Tegra 2 lze vidět na obrázku níže \ref[TEGRA].

\medskip
\clabel[TEGRA]{Popis jádra NVIDIA Tegra 2.}
\picw=15cm \cinspic images/tegra2.pdf
\caption/f Obrázek popisuje architekturu procesoru NVIDIA Tegra 2 \cite[TEGRA].
\medskip

\label[ASIX]

\sec Asix AX88772b


AX88772b je zákaznický integrovaný obvod vyráběný firmou Asix, který umožňuje plug--and--play Fast Ethernet internetové připojení pro zařízení využívající stantardizované USB verze 1.1 a verze 2.0 \ref[USB].


Jako jediný z výraběných modelů dosahuje v revizi AX88772bli teplotních rozsahů od -40 stupňů Celsia až +85 stupňů Celsia.
%x^{\circ}
AX88772b má modifikovatelnou vícefunkční sběrnici, která umožňuje připojit RMII \ref[RMIIsub] nebo Reverse-RMII způsobem MAC--to--MAC k mikrokontroléru s Ethernet MAC RMII rozhraním.
MAC rozhraní je plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u.

%TODO ASIX
\medskip
\clabel[ASIXcip]{Blokový diagram AX88772b.}
\picw=15cm \cinspic images/asix_conn.pdf
\caption/f Obrázek popisuje blokový diagram architektury čipu AX88772b od firmy Asix. Obrázek je převzat z \cite[ASIX].
\medskip
%jake umoznuje propojeni po rmii?

Jak je vidět na obrázku \ref[ASIXcip], čip AX88772b obsahuje ethernetovou vrstvu PHY, která nemůže být aktivní současně s RMII rozhraním.
%TODO jeste neco k obrazku

\label[MARVELL]

\sec Marvell 88E6065

Marvell 88E6065 je 5~+~1 portový ethernetový přepínač integrovaný na čipu.
Obsahuje  pět portů na fyzické vrstvě 10~BASE-T/100~BASE-TX, z nichž dva porty mohou být využity pro optickou linku 100~BASE-FX,
Navíc obsahuje port, který je nezávislý Fast ethernet MAC. %TODO divné
Zařízení má vysokorychlostní neblokující čtyřúrovňový QoS
\fnote{QoS je kontrolní mechanismus, který garantuje přenosovou kapacitu.}. %TODO 
Vrstva PHY tohoto zařízení podporuje plug-and-play s možností automatického určení směru, automatického určení polarity a automatického určení rychlosti.
Zařízení dále podporuje 64 z 4096 802.1Q WLAN s 3 úrovňovou ochranou.
Obsahuje dvě RMII/MII/SNI rozhraní, která mohou být připojena k menežovacímu rozhraní nebo ke kontroleru s integrovanou MAC.

MAC a PHY rozhraní jsou plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u a IEEE~802.3x.
Zařízení může být konfigurováno přes menežovací rozhraní nebo může načítat nastavení z EEPROM paměti.

Výjimečně se Marvell 88E6065 může využívat jako směrovač či výchozí brána.
%jake umoznuje porjojeni RMII
\medskip
\clabel[MARVELL6060]{Blokový diagram 88E6060.}
\picw=15cm \cinspic images/6060conn.pdf
\caption/f Obrázek popisuje blokové zapojení čipu 88E6060 od firmy Marvell, které je velmi podobné zapojení čipu 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

%TODO jak lze videt na obrazku \ref[MARVELL6060] ...

\label[SWITCH]

\sec Deska konfigurovatelného přepínače


Deska konfigurovatelného přepínače byla vyrobena firmou Retia a.s.
\fnote{Firma zabývající se elektronickými vojenskými systémy, záznamovými zařízeními a lokalizačními a bezpečnostními systémy. \url{www.retia.cz}}
na základě jejich návrhu a zapojení, ktará jsou popsaná v přílohách \ref[zapojeni], \ref[zapojeni2], \ref[zapojeni3].

Tato deska byla vyrobena za účelem nahrazení staršího modelu konfigurovatelného přepínače, který splňuje industriální teplotní rozsahy, za výkonnější.

Zjednodušené schéma této desky je znázorněno na obrázku \ref[deska].

\medskip
\clabel[deska]{Blokové schéma desky konfigurovatelného přepínače.}
\picw=15cm \cinspic images/diagdeska.pdf
\caption/f Obrázek popisuje blokové zapojení desky konfigurovatelného přepínače.
\medskip

Konfigurovatelný přepínač umožňuje nastavení ethernetoveho přepínače za pomoci USB Ethernet kontroléru AX88772b od firmy Asix \ref[ASIX], ke kterému je připojena externí pamět EEPROM M93-C66 \fnote{ Odkaz na pamet TODO}.
Tento kontrolér je připojen přes RMII rozhraní k čipu Marvell 88E6065 \ref[MARVELL] tak, jak lze vidět na obrázku níže \ref[MARVELL6065rmii].

\medskip
\clabel[MARVELL6065rmii]{Zapojení RMII k čipu Marvell 88E6065.}
\picw=10cm \cinspic images/rmii.pdf
\caption/f Obrázek popisuje připojení RMII rozhraní k zařízení Marvell 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

K tomuto čipu je také připojena externí pamět eeprom.

Oba čipy Asix AX88772b a Marvell 88E6065 mají vlastní krystal s frekvencí 25~MHz.
Deska je navíc osazena regulátorem napětí a přepínači pro různá nastavení MII rozhraní(K3 a K2), resetování(K5) a externí vzbuzení(K4), jak je možno vidět v příloze \ref[zapojeniXXX].

\label[impl]

\chap Implementace

Tato kapitola rozebírá portaci aktuálního Linuxového jádra pro modul Colibri T20 \ref[T20], která byla zapotřebí pro další implementaci ovladačů.
Dále se zabývá způsobem oživení desky konfigurovatelného přepínače \ref[SWITCH] a následným popisem tvorby ovladače pro tento přepínač \ref[ARCH] a jeho implementace \ref[ZPRAC].

Vývoj byl prováděn na vývojovém kitu s modulem Colibri T20.
Pro vývoj ovladače bylo zvoleno jádro z upstreamové větve Linuxového jádra
\fnote{Linuxové jádro je možné stáhnout na \url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git}}.
Práce byla započata s verzí Linuxového jádra 3.17, a vzhledem k aktualizacím jádra byla přeportována na verzi 3.19.

\label[UPSTREAM]

\sec Portace upstreamového Linuxového jádra a zavaděče

Pro portaci upstreamového Linuxového jádra bylo vyžadováno několik nástrojů a programů pro překlad kódu, linkování a nahrání do paměti.

\secc U-Boot

Jako první krok bylo potřeba nainstalovat zavaděč, který by se postaral o zavedení Linuxového jádra na modul Colibri T20.
Pro tento úkol byl zvolen zavaděč U-Boot, který je využíván i výrobcem modulu Colibri T20, avšak byla zvolena jeho novejší verze
\fnote{U-Boot je možný stáhnout z repozitáře \url{git://git.denx.de/u-boot.git}}.

V následujícím kroku bylo nutné stáhnout a zkompilovat tento nejnovější zavaděč \cite[UPLINUXT20].
Jako konfigurační soubor byl zvolen {\em colibri\_t20\_iris\_config}, který popisuje modul Colibri T20 s vývojovou deskou Iris.

\begtt
$ git clone git://git.denx.de/u-boot.git
$ export CROSS_COMPILE=~/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
$ export ARCH=arm
$ make colibri_t20_iris_config
$ make -j8
\endtt

Dále bylo potřeba stáhnout nástroje, které by sloužily k vytvoření cílového binarního souboru zavaděče U-Boot.

\begtt
$ git clone https://github.com/NVIDIA/cbootimage-configs.git
$ cbootimage -gbct -t20
		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.bct.cfg
 		colibri-t20_512_v12_nand.bct
$ cp ../u-boot/u-boot-dtb-tegra.bin u-boot.bin
$ cbootimage -t20
 		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.img.cfg
 		colibri-t20_512_v12_nand.img
\endtt

Poté byl zaveden zavaděč z diskového souboru  následujícím příkazem:

\begtt
$ tegrarcm --bct colibri-t20_512_v12_nand.bct --loadaddr=0x00108000
 		--bootloader=../u-boot/u-boot-dtb-tegra.bin
\endtt

Po zavedení tohoto zavaděče bylo možné sledovat, jak se na konzoli modulu Colibri T20 zobrazil výpis tohoto zavaděče.
A za pomoci USB-ethernetového kontroléru, který je integrovaný na modulu, byl nahrán obraz zavaděče do paměti modulu.

\begtt
Tegra20 (Colibri) # usb start
(Re)start USB...
USB1: USB EHCI 1.00
scanning bus 1 for devices... 1 USB Device(s) found
USB2: USB EHCI 1.00
scanning bus 2 for devices... 2 USB Device(s) found
 scanning usb for storage devices... 0 Storage Device(s) found
 scanning usb for ethernet devices... 1 Ethernet Device(s) found
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot 0x02100000 colibri-t20_512_v12_nand.img
Waiting for Ethernet connection... done.
TFTP from server 192.168.80.3; our IP address is 192.168.80.90
Filename 'colibri-t20_512_v12_nand.img'.
Load address: 0x02100000
Loading: #################################
         3.6 MiB/s
done
Bytes transferred = 729088 (b2000 hex)
\endtt

Bylo nutné nahrát obraz zavaděče do paměti a přepsat původní zavaděč současným.
Délka přeneseného obrazu byla 0xb2000, viz výše.
Tato hodnota byla potřeba k určení délky přepisovaného úseku NAND paměti.

\begtt
Tegra20 (Colibri) # nand erase.chip

NAND erase.chip: device 0 whole chip
Erasing at 0x3ffc0000 -- 100% complete.
OK
Tegra20 (Colibri) # nand write 0x02100000 0 0xb2000

NAND write: device 0 offset 0x0, size 0x95000
 577536 bytes written: OK
\endtt

Při resetu zařízení bylo možno vyčíst z konzole náběh nového upstramového zavaděče U-Boot, který ale v tento moment nebyl schopen nalézt žádné jádro operačního systému.
Jádro bylo přidáno v dalším kroku popsaného v sekci \ref[LINUXkernel].

\label[LINUXkernel]

\secc Linuxové jádro

Následujícím krokem  byla instalace aktuální verze jádra, která byla nutná k vývoji ovladačů a komunikaci s linuxovou komunitou.
Jelikož upstreamové jádro nepodporuje NAND paměť, načítání tohoto jádra bylo realizováno přes ethernetovou síť \cite[UPLINUXT20].

Pro instalace linuxového jádra bylo potřeba stáhnout a přeložit nejnovější verzi \cite[UPLINUXT20].
Pro nastavení jádra byla zvolena konfigurace {\em tegra\_defconfig}, která v jádře vybere moduly a ovladače pro jeho běh.

\begtt
$ git clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ export LOADADDR=0x408000
$ export ARCH=arm
$ export CROSS_COMPILE=/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
$ make tegra_defconfig
$ make -j8 uImage
\endtt

Po přeložení nejnovější verze bylo možno nahrát obraz jádra a přeloženého device tree
\fnote{Device Tree popisuje hardwarového zapojení modulu.}
do RAM paměti modulu za pomoci USB-ethernetového kontroléru v konzoli zavaděče U-Boot následujícími příkazy:

\begtt
Tegra20 (Colibri) # usb start
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot ${kernel_addr_r} uImage
Tegra20 (Colibri) # tftpboot ${fdt_addr_r} tegra20-iris-512.dtb
\endtt
%Load address: 0x1000000 kernel
%Load address: 0x2000000 dbt

Po nahrátí obrazů  byly nastaveny parametry pro Linuxové jádro
\fnote{\url{https://www.kernel.org/doc/Documentation/kernel-parameters.txt}},
tedy nastavení konzole, jejího portu a rychlosti, dále pak nastavení oddílu s distribucí a jejího typu filesystému.
Pokud v nastaveném oddílu bude nahrána distribuce se správným formátem, jádro tuto distribuci zavede.
Poté je možno spustit přeložené Linuxové jádro.

\begtt
Tegra20 (Colibri) # set bootargs console=ttyS0,115200n8 earlyprintk
		root=/dev/mmcblk0p1 rootfstype=ext2 rw rootdelay=1
Tegra20 (Colibri) # bootm ${kernel_addr_r} - ${fdt_addr_r}
\endtt



\sec Oživení desky

Pro oživení desky byl nejprve testován USB kontrolér Asix AX88772b \ref[oAX].
Po oživení komunikačního rozhraní tohoto kontroléru bylo dalším krokem ladění ethernetového přepínače Marvell 88E6065 \ref[oMV].
Nakonec bylo provedeno testování ethernetových portů celého systému.
V průběhu tohoto testování bylo objeveno několik chyb v návrhu desky. která byla na základě mých připomínek opravena(XXX to zaveru).

\label[oAX]

\secc Oživení Asix AX88772b

%jak jsi oživoval Asix?
V průběhu oživování USB kontroléru byla objevena závada v jeho připojení na desce konfigurovatelného přepínače.
Tato závada se projevovala chybnou komunikací na USB sběrnici, která byla objevena při použití modulu Colibri T20.
Tato chybná komunikace je znázorněna na obrázku \ref[usbbuserr].
Je zde znatelné, že pakety, které dorazily k hostovskému zařízení, modul příjímal poškozené.

\medskip
\clabel[usbbuserr]{Chybná komunikace na USB sběrnici.}
\picw=15cm \cinspic images/wrong_com_wire.pdf
\caption/f Na obrázku je znázorněna chybná komunikace na USB sběrnici mezi PC a USB kontrolérem Asix AX88772b, která byla zaviněna nepřipojením blokovacího kondenzátoru.
\medskip

Po úpravě zapojení kontroléru začal USB kontrolér odpovídat na dotazy aktuálního ovladače v operačním systému Linux.


\medskip
\clabel[ASIXRMII]{Připojení RMII k USB kontroléru Asix AX88772b.}
\picw=15cm \cinspic images/asix_rmii.pdf
\caption/f Obrázek zobrazuje připojení vrstvy PHY nebo rozhraní RMII.
\medskip

Na obrázku \ref[ASIXRMII] lze vidět, že kontrolér AX88772b není schopen komunikovat po rozhraní PHY a RMII současně.
Zápisem do registru číslo 0 \cite[ASIXman] je aktivován právě jeden z daných dvou rozhraní a následně pomocí spojky K2 \ref[zapojeni3] je kontrolér nastaven do režimu MAC.

Posledním krokem k oživení USB kontroléru Asix AX88772b bylo nastavení vhodného chování tak, aby bylo zprovozněno rozhraní RMII, které je blíže popsané v \ref[ZPRAC].
%TODO popsat vhodné chování

\label[oMV]

\secc Oživení ethernetového přepínače Marvell 88E6065

K oživení a stabilnímu chování ethernetového přepínače Marvell 88E6065 bylo zapotřebí aktivovat RMII rozhraní a provést několik zásahů do zapojení čipu na desce.
Taktéž bylo zapotřebí aktivovat funkční komunikaci přes Asix AX88772b \ref[oAX], který na základě USB příkazů je schopen posílat menežovací zprávy přes RMII rozhraní.
Navíc bylo potřeba vyřešit, v jakém módu bude tento ethernetový přepináč, na kterém bylo zvoleno připojení MAC--to--MAC, ve kterém hodiny pro MDIO vysílá zařízení AX88772b a hodiny o frekvenci 50~MHz pro RMII rozhraní ethernetový přepínač Marvell 88E6065. Zapojení je znázorněno na obrázku \ref[MARVELL6065rmii].

Protože i na tomto čipu byla nalezena chyba v komunikaci, byly doplněny chybějící blokovací kondenzátory.
Navíc byl objeven problém, že  tento čip se po každém zapnutí nastavil do odlišných nastavení.
Pro vyřešení tohoto problému byl k čipu doplněn kondenzátor, který zařízení opakovaně resetoval po dobu časové konstanty RC. 
Deska tak měla během této doby možnost, aby vstupní hodnoty na všech pinech se ustálily ve správném stavu.
Pro zajištění správného a deterministického chováni přepínače byly přidány pull-up a pull-down rezistory.
\begitems
\enditems

\label[ARCH]

\sec Návrh ovladače

Návrh ovladače byl založen na propojení ovladače pro Asix AX88772b a subsystému DSA \ref[DSA].

Celý ovladač by měl fungovat, tak že při připojení USB zařízení se zavede ovladač pro zařízení AX88772b.
Ta inicializuje tento ovladač do standardního stavu na zákaldě funkce usb\_probe(), která na základě ID produktu a výrobce vybere správný ovladač.
V našem případě je to ax88772b\_info, která je instancí stuktury driver\_info.
Tato struktura je v současné době naimplemntováno v aktuální verzi Linuxové jádra.
To je takové, že ovladač aktivuje PHY interface a vytvoří rozhraní pro ethernetovou komunikaci přez net\_device strukturu a ethtool\_ops a net\_device\_ops funce.
Doplní se funkce, která vytvoří node v sysfs\ref[SYSFS].
Za pomoci obslužné rutiny nodu v sysfs spojí usbnet zařízení s DSA subsystémem.
Tato rutiny předá DSA subsystému instance struktur net\_device, mii\_bus a o potrech switche ve struture dsa\_platform\_data. Všechny tyto instance nebo jejich reference nese platform\_device. Tyto struktury můžeme vidět v \ref[umlDSA].

Za pomocí těchto dat, se v DSA subsystému aktualizuje celý ovladač.
Ten si nejde potřebný ovladač ke konkrétnímu přepínači a pro každý port vytvoří vlastní síťové rozhraní.

Proces uvolňování je rešen při funcí XXX ta uvolňuje celý subsystém DSA a na něm zavislé instance.
Tato funce, nejdrive vyvolá uvolnění v subsytému DSA a poté uvolní časti v AX88772b.

\label[ZPRAC]

\sec Zpracování

Sekce zpracování popisuje jednotlivé časti ovladače.

Jelikož nebyl ovladač pro zařízení Asix AX88772b připraven na připojení RMII rozhraní.
Bylo potřeba nastavit tento interface jako aktivní, ten však nemůže být aktivní současně s ethernet PHY, která je taktéž integrovaná na čipu jak je vidět \ref[ASIXRMII].
Implementace oladače je popsána v \ref[asixdri].

Dále bylo potřeba upravit subsystém DSA, aby podporoval hotswap zařízení, konkrétně jeho odhlašovnání a uvolňování. Popsaný v \ref[dsadri].

Poslední částí bylo napsat samotný ovladač pro Marvell 88E6065, který řeší veškerou funkčnost samotného přepínače. Popsaném v \ref[mvdri].

\label[asixdri]

\secc Ovladač zařízení Asix AX88772b

Asix AX88772b má již podporu v Linuxovém jádře a však pouze na jedno z jeho rozhraní.
Tím rozhraním je ethernet PHY \ref[ASIX]. Bylo potřeba doplnit ovladač o aktivaci RMII rozhraní.
A byla zvolena možnost, že aktivace RMII rozhraní proběhne přez zápis do souboru {\em dsa\_bind}, áež je součástí file systému sysfs, a je umístěn ve složce USB zařízení.
Po zapsání do tohoto souboru se vyvolá obslužná rutina objektu {\em usb\_dsa\_store() }, která je nainicializována strukturou  kobj. Tato rutina převezme informace o tom, kdo ji zavolal a  vyvolá {\em dsa\_bind()}
Ta nastaví příslušné registry pro aktivování RMII rozhraní, zapsaním do příslušných registrů.
Nadále tato rutina též otestuje zdali, je k USB kontroléru připojeno zařízení Marvell 88E6065, dle standardizovánému registrovému prostoru \ref[miireg].
Konkrétně vyčtením z třetího registru z \ref[miireg], která obsahuje ID a revizy zařízení.
Tato část obslužné rutiny též vyplní strukturu {\em asix\_common\_private}, které v současné verzi kompatibilní s jadrem verze 3.19 vypadá následovně:

\begtt
struct asix_common_private {
   struct asix_rx_fixup_info rx_fixup_info;
#ifdef CONFIG_NET_DSA
   struct kobject kobj;
   struct mii_bus *mdio;
   bool use_embphy;
   bool dsa_up;
   struct usbnet *dev;
   struct platform_device *pdev;
#endif
}
\endtt

%Ve verzi linuxového jádra 3.19 subsystém DSA byl upraven a nevyžaduje strukturu {\em mii\_bus} a byl odstraněn a je nahrazena  strukturou {\em platform\_device}, aby se vyhnulo většině změn v subsystému DSA dle připomýnky v mailing listu \ref[ML].
Starší verze této struktury neobsahovala platform\_device, ten byl doplněn na základě připomýnky z komunikace mezi mnou a vývojáři Linuxového jádra \ref[ML].
A proto ovladač zařízení Asix AX88772b byl doplněn o funkci {\em dsa\_create\_pdev}, která zajistí naplnění struktury {\em platform\_device}.
Tato struktura se vytváří při po kontrole zařízení ve funkci {\em dsa\_bind}.

Po naplnění základních struktur ovladač Asix AX88772b zavolá {\em dsa\_probe\_netdevice()}, který vytvoří softwarové rozhrání přepínače. Změna DSA subsystému je popsaná v \ref[dsadri].

\label[dsadri]

\secc Úprava subsystému DSA

Subsystém DSA byl rozšířen o veřejnou funkci {\em dsa\_probe\_netdevice()}, která vytváří softwarové rozhraní pro přepínač.
Každý port přepínače je reprezentován vlastním ethernetovým rozhraním net\_device \ref[NETDEV], které mají společného rodiče stejného typu.

Bylo potřeba odloučit DSA od platform\_driveru což následně zapříčiňuje rozšíření dsa\_switch\_driver \ref[mvdri].

Větší rozsah změn čekala uvolňovací část ovladače.
Jelikož se nepředpokladá, že by se tento ovladač někdy uvolňoval, které pline z debaty na \cite[ML].
Tato funce nebyla dodělána a proto byla upravena {\em dsa\_destroy()}, která v současné verzi podporuje uvolnění všech portů a interních struktur DSA ovladače jako je struktura {\em dsa\_switch a dsa\_switch\_tree}.


\label[mvdri]

\secc Ovladač zařízení Marvell 88E6065

Bylo zapotřebí vytvořit ovladač pro zařízení 88E6065 od firmy Marvell, který nemá žádnou podporu v Linuxovém jádře.

Tento ovladač je instancí dsa\_switch\_driver jak je možné vidět na obrázku \ref[umlDSA].
Struktura dsa\_switch\_driver obsahuje metody, které zajišťují nainicializování, uvolňení a nastavění switche jako celku a jednotlivých portů.



\sec Spojení jednotlivých ovladačů


Všechny ovladače dělají svou partikulární část. Na připojení USB a příjmutí ID se zavede ovladač AX88772b, který aktivuje PHY. Po zapisu do souboru dsa\_bind se v adresáři přislušného USB zařízení se aktivuje druhé rozhraní ovladače a nainicializuje DSA strukturu. Tato struktura vytvoří dostatek ethernetových rozhraní a připojí příslušný ovladač pro přepínací obvod.

Nyní na základě příkazů pro ethtool můžeme komunikovat s ovladačem skrz uživatelský prostor.

\sec Odezva komunity

Odezva komunity byla velmi rychlá po odeslaní RFC patche
\fnote{\url{http://lists.openwall.net/netdev/2015/04/21/20}}.
se mi dostalo odpovědi během pouhých pár hodin.
Kde Andrew Lunn se vyjádřil k mému nápadu a navrhl nějaké optimalizace k mému řešení.
Také se strhla debata o možnostech DSA, že DSA není připravené pro podporu hotswap zařízení.
A pravděpodobně tato změna nenastane ani v příštích verzích Linuxového jádra.
Další věcí o které padla řeč, je že se pravděpodobně celý subsystém DSA přepíše.

\chap Otestujte implementované řešení zejména s ohledem na propustnost sítě a stabilitu

Tato kapitola se zabiva

\begtt
[11.046] Unable to handle kernel paging request at Virtual Addr 6b6b6b77
[11.053] pgd = c0004000
[11.055] [6b6b6b77] *pgd=00000000
[11.059] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
[11.064] Modules linked in:
[11.067] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.19.0 #298
[11.075] Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
[11.082] task: c08ba2a8 ti: c08ae000 task.ti: c08ae000
[11.087] PC is at get_next_timer_interrupt+0xa0/0x294
[11.092] LR is at get_next_timer_interrupt+0x60/0x294
[11.098] pc : [<c006f474>]    lr : [<c006f434>]    psr: 90000093
[11.098] sp : c08aff00  ip : 6b6b6b6b  fp : 00000000
[11.109] r10: c0927540  r9 : ffff8f21  r8 : ffff8f20
[11.114] r7 : 00000000  r6 : 3fff8f1f  r5 : ffff8f20  r4 : ffff8f17
[11.121] r3 : 6b6b6b6b  r2 : 00000021  r1 : 00000023  r0 : c0927674
[11.127] Flags: NzcV IRQs off FIQs on Mode SVC_32 ISA ARM Segment kernel
[11.135] Control: 10c5387d  Table: 1ac0404a  DAC: 00000015
[11.140] Process swapper/0 (pid: 0, stack limit = 0xc08ae238)
[11.146] Stack: (0xc08aff00 to 0xc08b0000)
[11.151] ff00: c08affa4 c060ecc0 0000001d c00625f0
    fe44010c 0000000d c08aff40 c08b7154
[11.159] ff20: 755c2278 00000002 c08ac640 60000000
    00000185 dbbb4280 00000000 ffff8f20
[11.216] [<c006f474>] (get_next_timer_interrupt)
    from [<c007e34c>] (__tick_nohz_idle_enter+0x2d4/0x41c)
[11.226] [<c007e34c>] (__tick_nohz_idle_enter)
    from [<c007e4e0>] (tick_nohz_idle_enter+0x30/0x6c)
[11.235] [<c007e4e0>] (tick_nohz_idle_enter)
    from [<c00552c4>] (cpu_startup_entry+0x18/0x278)
[11.244] [<c00552c4>] (cpu_startup_entry)
    from [<c0868c0c>] (start_kernel+0x360/0x3cc)
\endtt

\sec propustnost

\sec porovnani s jinym eth interfacem

\sec Konfigurace

Konfigurace přepínače probíhá skr konfiguraci nástroji ifconfig a vconfig

co se testuje a jak se testuje(co pisu za prikazy) -> vysledky

\sec logterm

\chap Zaver

funguje, odezva, linuxova komunita, dosazene vysledky, vykon
MII,RMII,GMII,RGMII,SGMII,QGMII,XAUI
