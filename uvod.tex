\chap Úvod
%citace
%iperf
%distribuce
%zaver
%abstrakt
%zkontrolovat kapitoli a obrazky
%XXX TODO linearo

Cílem mé diplomové práce je~vytvoření ovladače do~operačního systému Linux pro~Ethernetový přepínač, který by splňoval průmyslové teplotní rozsahy.


Tyto přepínače se~v~dnešní době téměř nevyrábějí a~moduly, které by splňovaly tyto teplotní rozsahy a~měly integrované MII rozhraní, které složí ke komunikaci s~přepínači a~Ethernetovými fyzickými vrstvami, jsou finančně velmi nákladné.
Proto se~tato práce zabývá možností připojení Ethernetového přepínače pomocí USB sběrnice, což umožní dosáhnout požadovaných vlastností levnějším způsobem.

Vytvoření tohoto ovladače bylo zadáno firmou Retia a.s. se~sídlem v~Pardubicích.
Tato firma se~zabývá tvorbou elektronických vojenských systémů, záznamových zařízení a~lokalizačních a~bezpečnostních systémů.
Účelem je~nahrazení staršího modelu konfigurovatelného přepínače, který splňuje industriální teplotní rozsahy, za~výkonnější.
Firma poskytla pro~tuto práci modul Colibri T20
\fnote{\url{https://www.toradex.com/computer-on-modules/colibri-arm-family/nvidia-tegra-2}}
a konfigurovatelný přepínač i s~návrhem jeho zapojení.
Přepínač je~založen na~přepínacím obvodu 88E6065, který je~vyvinut firmou Marvell a~který tvoří jádro samostatné desky plošných spojů.
Deska konfigurovatelného přepínače je~připojena Ethernetovým kontrolérem s~USB rozhraním AX88772b, vyraběným firmou Asix, který podporuje připojení fyzické vrstvy za~pomoci rozhraní RMII.

Pro vytvoření ovladače bylo potřeba provést portaci operačního systému Linux na~modul Colibri T20, který má integrované hostitelské USB rozhraní a~splňuje průmyslové teplotní rozsahy.
Dálé bylo nutné implementovat ovladače do~operačního systému Linux pro~zařízení přepínacího obvodu s~možností inicializace za~běhu.
Implementace byla provedena na~současné verzi Linuxového jádra se~snahou zařadit ovladač do~hlavní větve Linuxového jádra.

\medskip

Práce má následující strukturu.
Ve druhé kapitole \ref[pouztech] je~popsána použitá technologie, jako je~sběrnice USB,  MII rozhraní i rozšířené rozhraní RMII.
Tato kapitola se~také věnuje popisu relevantních Linuxových subsystémů -- síťového, USB a~subsystému přepínače.

V kapitole \ref[pouzhw] Použitý Hardware je~popsán zvolený procesorový modul Colibri T20 a~použitá deska konfigurovatelného Ethernetového přepínače.
Zvláštní důraz je~kladen na~popis čipů použitých na~této desce -- USB kontrolér Asix AX88772b a~přepínací obvod Marvell 88E6065.

V následující kapitole \ref[impl] s~názvem Implementace je~popsán postup nahrání nového Linuxového jádra a~navazující postup při oživování desky.
Dále pak popisuje architektonický návrh daného ovladače pro~operační systém Linux a~rozebírá implementaci tohoto návrhu.

V kapitole \ref[TEST] s~názvem Testování je~popsáno, jak bylo testováno nastavení přepínacího obvodu.
Dále se~zde popisují proběhlé testy ovladače přepínacího obvodu.
Na závěr kapitoly jsou výsledky těchto testů vyhodnoceny.

\label[pouztech]

\chap Použité technologie

V této kapitole je~popsána použitá technologie.
První část je~věnovaná popisu sběrnice USB, která je~popsána v~\ref[USB].
V další části je~popsáno rozhraní Media Independent Interface (MII).
Ke konci této kapitoly je~pojednáváno o~tom, jak vypadají ovladače v~operačním systému Linux a~jak vypadá rozhraní Linuxového subsystému Distributed Switch Architecture, které je~použito pro~daný ovladač a~s ním související subsystémy.

%LDD3 pekny popis zarizeni http://www.makelinux.net/ldd3/?u=chp-13-sect-4
%MAC podporuje 802.3 a~802.3u MAC funkce, jako je~prijem a~odeslani ramce, kontrolu CRC, duplex mode, forwarding, flow-control, detekce kolizi atd.

%\label[ISO]
%\sec Model ISO/OSI
%Model ISO/OSI je~konceptuální model, který charakterizuje komunikačních sítích. Rozdělaná do~vrstev.

\label[USB]

\sec Univerzální sériová sběrnice

Univerzální sériová sběrnice (USB) je~technický standard vyvíjený od roku 1994 pro~připojení periferií k~počítači.
Tato sběrnice měla nahradit pomalé sběrnice (jako jsou sériová linka, paralelní port, PS2 a~mnohé další) jednou sběrnicí \cite[LDD3].
V dnešní době USB umožňuje přenášet velké množství dat s~rychlostí až 640 MB/s u USB zařízení verze 3.0.
Díky tomu se~použití USB rozšířilo a~nyní je~podporováno skoro každým druhem zařízení, které umožňuje mimojiné přenašet video, audio či dokonce i Ethernetové rámce.
Podporovaná zařízení jsou rozdělena do~tříd z~důvodu sjednocení funkcionality a~chování zařízení.
Nejznámějšími třídami jsou Human Interface Device, Printer a~Mass Storage, které jsou více popsány ve~vývojářské dokumentaci \cite[USB].
Toto sjednocené chování má za~důsledek využívání společných ovladačů, které mohou uživatelé využívat pro~práci s~těmito zařízeními.
Problém s~některými druhy zařízení je~takový, že je~nejde do~daných tříd zařadit, popřípadě mají rozšířené chování a~potřebují speciální přístup.

\secc Rysy USB zařízení

USB sběrnice využívá metodu Master/Slave pro~přístup k~médiu a~podporuje detekci připojeného zařízení za~běhu (plug--and--play) a~následnou automatickou konfiguraci (hotplug).
USB síť se~skládá ze tří druhů zařízení \cite[USB]:
\begitems
*Hostitel -- je~zařízení typu Master a~je jako jediný v~systému, řídí komunikaci a~obvykle integruje rozbočovač označený jako kořenový.
Přiděluje zařízením unikátní adresy v~síti.
*Rozbočovač -- distribuuje datové toky a~identifikuje připojení a~odpojení dalších zařízení.
*Zařízení -- pojmem zařízení je~míněno koncové zařízení s~požadovanou funkcionalitou, které odpovídá na~řídící zprávy.
\enditems

USB zařízení je~asymetrická sběrnice se~stromovou topilogií a~s jedním zařízením typu Master.
Strom je~složený z~linek bod-bod, přičemž USB rozbočovače vytvářejí jednotlivé uzly tohoto stromu a~zařízení tvoří jejich listy.
Linky USB sběrnice jsou 4--vodičové skládající se~z diferenciálního páru datových linek, napěťového a~zemnícího vodiče, které jsou připojeny k~zařízení a~USB rozbočovačům.
USB umožňuje připojit až 127 zařízení v~rámci jedné USB sítě o~hloubce maximálně pěti rozbočovačů tak, jak můžeme vidět na~obrázku \ref[USBhub].

\medskip
\clabel[USBhub]{Příklad topologie USB sběrnice.}
\picw=13cm \cinspic images/technet.microsoft.com.jpg
\caption/f Příklad topologie sběrnice USB. Obrázek převzat z~\cite[MSTECH].
\medskip


Díky tomu, že sběrnice USB je~typu Master/Slave, umožňuje jednoduchý mechanismus detekce a~enumerace, nebo-li průběhu konfigurace (více informací níže \ref[USBkom]), za~běhu systému.
Průběh enumerace je~řízen a~konfigurován automaticky hostitelem.


\label[USBkom]

\secc Komunikace

USB komunikace je~založena na~logických kanálech, tzv. rourách.
Každému výstupnímu kanálu by měl odpovídat právě jeden vstupní.
Koncový bod obsahuje rouru s~definovaným směrem.

USB může mít maximalně 30 koncových bodů. Koncový bod je~asociován s~rourou, která má předem definovaný směr a~typ přenosu:

\begitems
*Řídící -- obousměrná roura sloužící ke konfiguraci zařízení. Každé zařízení disponuje tímto druhem roury. Má rezervovanou určitou přenosovou kapacitu.
*Izochronní -- jednosměrná roura sloužící ke stálému přenosu většího objemu dat. Má garantovanou latenci, přenos však není spolehlivý. Tento typ roury je~vhodný pro~audio a~video.
*Přerušovací -- jednosměrná roura sloužící pro~časté přenosy malého množství dat. Má garantovanou šířku pásma. A přenos dat je~spolehlivý. V případě chyby se~přenos opakuje.
*Blokový -- jednosměrná roura sloužící k~přenosu velkého množství dat. Nemá rezervovanou žádnou přenosovou kapacitu ani dobu odezvy. Komunikace po této rouře je~spolehlivá a~v případě chyby se~přenos opakuje.
\enditems

Koncové body jsou inicializovány v~průběhu enumarace USB zařízení, která probíhá po kontrolní rouře označené číslem 0, která je~unikátní pro~každé zařízení a~jako jediná z~rour je~obousměrná.

Enumerace je~posloupnost standardizovaných příkazů, kterou započal hostitel.
V průběhu enumerace se~předávají deskriptory, které obsahují důležité informace o~zařízení.
Hierarchii deskriptorů lze vidět na~obrázku \ref[USBhier].

\medskip
\clabel[USBhier]{Hierarchije USB deskriptorů.}
\picw=13cm \cinspic images/IMG019.pdf
\caption/f Hierarchie deskriptorů USB zařízení. Obrázek převzat z~\cite[LUSB].
\medskip


\begitems
*Deskriptor zařízení -- obsahuje informace jako je~identifikátoru (ID) výrobce a~produktu.
Též obsahuje informace o~třídě a~maximální délce paketů, které může roura 0 přijmout.
*Konfigurační deskriptor -- oznamuje, jak má být zařízení napájeno, jaký má zařízení maximální odběr proudu a~počet rozhraní.
Těchto dekriptorů může být více.
*Deskriptor rozhraní -- tento deskriptor informuje o~funkcionalitě celku, jako je~třída koncových zařízení a~počet koncových bodů.
*Deskriptor koncového bodu -- používá se~k~přesnému popisu koncového bodu.
*Textový deskriptor -- tento deskriptor přenáší pouze čitelné informace o~zařízeních v~kódování Unicode.
\enditems

Na základě informací v~deskriptorech se~operační systém rozhoduje, který druh ovladače přiřadí danému druhu zařízení.


\medskip \medskip \medskip \medskip

\label[MII]

\sec Media Independent Interface


Tato sekce předpokládá znalost modelu ISO/OSI.

Media Independent Interface (MII) je~typ rozhraní, které umožňuje připojení procesoru k~fyzickému médiu a~je na~těchto prvcích nezávislé.
Tento typ rozhraní je~specifikován standardem IEEE 802.3, který je~popsán v~[\cite[IEEE8023], kapitola 22].
MII propojuje dvě vrstvy modelu ISO/OSI, a~to vrstvu spojovou, konkrétně její část Media Access Constroll (MAC)
\fnote{MAC je~popsána standardem IEEE 802.2001. Stará se~o přijímání a~odesílání rámců (přístup k~médiu).},
s vrstvou fyzickou (PHY)
\fnote{PHY převádí bitový stream na~signál a~definuje jeho doručení.}.
MII rozhraní podporuje dva datové toky -- 10~Mb/s a~100~Mb/s.
Na obou datových tocích je~funkcionalita MII identická, liší se~pouze v~nominální frekvenci hodin.
Vyšší rychlosti přenosu je~možno dosáhnout použitím rozhraní na~Gigabite Media Independent Interface, které podporuje rychlost až 1~Gb/s.

\medskip
\clabel[MIItoISO]{Spojitost mezi MII a~ISO/OSI}
\picw=16cm \cinspic images/802_iso.pdf
\caption/f Spojitost mezi rozhraním MII, modelem ISO/OSI a~modelem IEEE 802.3 CSMA/CD LAN. Obrázek převzat z~\cite[IEEE8023].
\medskip

Na obrázku \ref[MIItoISO] je~vidět připojení MII na~Reconsiliation Sublayer (RS) a~Physical Coding Sublayer (PCS) nebo Physical Layer Signaling (PLS). %rozepsat zkratky
RS je~podvrstva, která mapuje signály z~MII na~MAC/PLS obsluhu.
PLS a~PCS jsou vrstvy, které se~starají o~kódování a~dekódování signálů.
Konkrétní mapování MII signálů znázorňuje obrázek \ref[RStoMII].

\medskip
\clabel[RStoMII]{Mapování signálů RS na~MII}
\picw=15cm \cinspic images/802_rs.pdf
\caption/f Mapování signálů podvrstvy RS mezi rozhraním MII a~vrstvou PLS. Také lze vidět připojení STA. Obrázek převzat z~\cite[IEEE8023].
\medskip

Jak můžeme vidět na~obrázku \ref[RStoMII], fyzické rozhraní MII se~skládá ze dvou druhů sběrnic, a~to datové \ref[MIIdat] a~ovládací (STA) \ref[MDIOs].
STA může být připojeno až k~32 fyzickým jednotkám, které obsluhuje.

\label[MIIdat]

\secc Datová část MII rozhraní

Datová část MII disponuje několika druhy signálů, které lze vidět na~pravé straně obrázku \ref[RStoMII].
Tyto signály jsou připojeny k~přemapovací vrstvě RS.
Vývody vysílající datové signály jsou: %TODO mozna lepsi popisek

\begitems
*TX\_CLK -- vývod vysílající referenční hodinový signál pro~synchronizaci signálů vysílaných po vývodech TX\_EN, TXD a~TX\_ER.
Zdrojem signálu TX\_CLK je~vrstva PHY.
Frekvence tohoto signálu by měla být 20\% z~nominální hodnoty přenosu dat, $\pm 100 ppm $.
*RX\_CLK -- vývod vysílající referenční hodinový signál pro~synchronizaci signálů vysílaných po vývodech RX\_DV, RXD a~RX\_ER.
Zdrojem signálu RX\_CLK je~podvrstva RS. %XXX kouknout na~manuál
RX\_CLK může odvodit referenční hodnotu frekvence z~přijímaných dat nebo z~nominální hodnoty jako u signálu vývoduu TX\_CLK.
*TX\_EN -- vývod vysílající signál, který indikuje, že je~podvrstva RS připravena odesílat data.
*TDX -- čtveřice datových vývodů vysílající signál (TDX[3:0]) ovládaná podvrstvou RS, která přenáší data synchronně na~základě signálu z~vývodu TX\_CLK.
TDX[0]  přenáší nejméně významný bit.
Pokud je~TX\_EN fyzicky odpojen, TDX nemá žádný efekt na~činnost vrstvy PHY.
*TX\_ER -- vývod vysílající signál řízený podvrstvou RS, který indikuje. že vrstva PHY začala vysílat jeden či více symbolů, které nejsou součástí dat, nebo že předčasně došlo k~přerušení rámce.
Signál na~tomto  vývodu je~synchronní s~hodinovým signálem z~vývodu TX\_CLK.
*RX\_DV -- vývod vysílající signál, který značí, že přijatá data jsou validní. Tento signál je~řízen vrstvou PHY a~je synchronní se~signálem z~vývodu RX\_CLK.
*RXD -- čtveřice datových vývodů vysílající signál (RDX[3:0]) ovládaná vrstvou PHY. Tato čtveřice vývodů slouží k~přenosu dat z~vrstvy PHY do~podvrstvy RS.
RXD[0] přenáší nejméně významný bit.
*RX\_ER -- vývod vysílající signál řízený vrstvou PHY, který indikuje, že nastala chyba detekovaná v~průběhu přijímání rámce.
Pokud je~vývod RX\_DV odpojen, vývod RX\_ER nemá žadný vliv na~činnost podvrstvy RS.
*CRS -- vývod vysílající signál indikující, zda je~příjemce nebo odesílatel zaneprázdněn, nebo je~ve~stavu idle.
Signál z~vývodu není synchronizován se~signálem z~vývodů TX\_CLK,  RX\_CLK.
Pokud je~bit z~registru 0.8, popsaný v~\ref[miireg], aktivní, signál na~vývodu má nedefinované chování. %XXX asi smazat
*COL -- vývod vysílající signál, který je~vyvolán vrstvou PHY, indikující kolize, které nastaly na~médiu.
Signál z~vývodu není synchronizován se~signálem z~vývodů TX\_CLK,  RX\_CLK.
Pokud je~bit z~registru 0.8, popsaný v~\ref[miireg], aktivní, signál na~vývodu má nedefinované chování. %XXX asi smazat
\enditems
%Reprezentuje pokud josu data na~odeslani nebo prijeti.

\medskip
\clabel[transiotionMII]{Komunikace po MII bez kolize.}
\picw=15cm \cinspic images/802_miicom.pdf
\caption/f Bezchybná komunikace po MII rozhraní. Obrázek převzat z~\cite[IEEE8023].
\medskip

Na obrázku \ref[transiotionMII] lze vidět, jak vypadá komunikace po MII rozhraní.
Pin TX\_CLK přenáší referenční hodinový signál, který se~pravidelně mění.
Při odesílání dat se~aktivuje signál z~vývodu TX\_EN.
Následně se~po vývodu  začne odesílat preambule.
Přenos těchto dat je~popsán níže.
S přijímaním signálu začne být příjemce zaneprázdněn, a~proto aktivuje signál z~vývou CRS.
Celá komunikace probíhá pouze jedním směrem a~neobsahuje žádnou chybu, jak je~možno vidět ze signálu na~vývodu COL.

Rámec dat, který je~přenášen po MII rozhraní, je~doplněn o~hlavičky a~patičky popsáné formátem:

\begtt
<vstupní rámec><preambule><sdf><data><edf>
\endtt

kde jednotlivé položky mají následující význam:

\begitems
*vstupní rámec -- je~doba mezi rámci, při které nesmí dojít k~žádné činnosti na~rozhraní MII.
Délka této periody není přesně specifikována.
*preambule -- je~definovaná posloupnost dat, která se~skládá ze 7 oktetů (bytů) a~je přenášena ve~formě pravidelného střídání jedniček a~nul.
*sdf -- oktet, který oznamuje začátek rámce.
*data -- značí přenesená data.
*efd -- konec rámce, který deaktivuje signál z~vývodu TX\_EN.
\enditems

Rámce jsou přenášeny tak, že oktet je~rozdělen na~dvě poloviny tzv. nibbles.
Tyto poloviny jsou odeslány po datových linkách TXD nebo RXD.
Příklad odeslání oktetu po signálech TDX je~znázorněn na~obrázku \ref[NIBBLE] níže.

\medskip
\clabel[NIBBLE]{Rozdělení oktetu po datových vývodech}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_nibble.pdf
\caption/f Rozdělení bytů, který je~následně odeslán po vývodech TDX. Obrázek převzat z~\cite[IEEE8023].
\medskip


\label[MDIOs]

\secc Ovládací rozhraní a~příslušný registrový prostor

Ovládací část sběrnice, která se~značí STA, se~používá k~nastavování a~čtení hodnot mezi vrstvami MAC a~PHY.
Toto rozhraní je~dvoulinkové sériové a~obsahuje dva datové vodiče:
\begitems
*MDC -- vývod vysílající signál určující časovou základnu pro~signál vysílaný vývodem MDIO.
Signál z~vývodu MDC je~aperiodický, nemá žádnou minimální ani maximální frekvenci, měl by se~však pohybovat v~rozmezí od 160 do~400~ns.
*MDIO -- vývod vysílající signál. Tento vývod je~vstupně výstupní a~jsou po něm posílány signály oběma směry.
Je tvořen třístavovým obvodem mezi vrstvami PHY a~STA.
Pin se~používá k~přenosu kontrolních zpráv mezi zařizeními.
Přenos je~řízen z~vrstvy PHY.
Signál z~vývodu MDIO je~synchronizovaný se~signálem z~vývodu MDC.
\enditems

Formát ovládacích rámců je~popsán v~tabulce \ref[MDIOframe].
Data z~této tabulky jsou odesílána po vývodu MDIO ve~směru z~levé strany tabulky do~pravé.

\midinsert \clabel[MDIOframe]{Formát ovládacích rámců.}
\ctable{lllllllll}{
 \hfil            & PRE & ST & OP & PHYAD & REGAD & TA & DATA & IDLE \crl \tskip4pt
          čtení   & 1...1 & 01 & 10 & AAAAA & RRRRR & Z0 & D...D & Z \cr
          zápis   & 1...1 & 01 & 01 & AAAAA & RRRRR & 10 & D...D & Z \cr
}
\caption/t Formát ovládacích zpráv. Tabulka převzata z~[\cite[IEEE8023], Tabulka 22-12].
\endinsert

V tabulce \ref[MDIOframe] lze vidět hodnotu preambule (PRE), což je~posloupnost 32 bitů skládajících se~z hodnot logických jedniček.
Preambule slouží k~synchronizaci signálu z~vývodu MDC.
Začátek rámce je~označený ST a~má hodnotu 01.
Poté jsou odesílána data popisující operační kód (OP), která určují druh operace: čtení nebo zápis.
PHYAD je~zkratka pro~fyzickou adresu zařízení o~délce 5 bitů.
Tím dokážeme naadresovat až 32 zařízení.
První bit adresy je~nejvíce významný bit.
Další položkou je~adresa registru (REGAD) číslovaná podle níže uvedených registrů \ref[miireg].
Dalším blokem je~TA.
Při operaci čtení hodnota TA obsahuje stav vysoké impedance (Z) sloužící k~prohození příjemce za~odesílatele, jak lze vidět na~obrázku \ref[mdioread].
Prohození odesílatelů probíhá z~důvodu požadavku odpovědi na~operaci čtení.
Odpovědí se~myslí vyžádaná hodnota z~registru.
Při operaci zápis tato změna není potřeba a~stav vysoké impedance je~nahrazen logickou jedničkou.
Odesílaná data mají 16 bitovou hodnotu, tedy stejnou jako je~velikost registrů.

\medskip
\clabel[mdioread]{Čtení registru po STA.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_miimdio.pdf
\caption/f Čtení z~registru při komunikaci po sériové ovládací lince STA. Obrázek převzat z~\cite[IEEE8023].
\medskip

Operacemi čtení a~zápis může vrstva MAC přistupovat k~registrovému prostoru na~vrstvě PHY, který tak může měnit.
Část tohoto registrového prostoru je~definována standardem 802.3.
Registrový prostor obsahuje dva základní skupiny registrů -- kontrolní a~stavový.
Všechny vrstvy PHY, které podporují rozhraní MII, by měly používat právě tyto skupiny registrů \ref[miireg].


\medskip
\medskip
\medskip
\clabel[miireg]{Registry STA rozhraní.}
\picw=15cm \cinspic images/802_miireg.pdf
\caption/f Registry STA rozhraní. Obrázek převzat z~\cite[IEEE8023].
\medskip


Tyto registry specifikují základní vlastnosti vrstvy PHY pro~MII rozhraní o~rychlostech 100~Mb/s a~1~Gb/s.
Registry 2 -- 14 jsou částí rozšířeného registrového prostoru \cite[IEEE8023] (22.2.4).
Bližší popis stavového a~kontrolního registru je~uveden v~přílohách \ref[MIIcntr] a~\ref[MIIstat].


% Ne do~DP
%\sec GMII

%The Gigabit Media Independent Interface (GMII) is similar to the MII. The GMII uses the MII management interface and register set specified in 22.2.4. These common elements of operation allow Station Management to determine PHY capabilities for any supported speed of operation and configure the station based on those capabilities. In a~station supporting both MII and GMII operation, configuration of the station would include enabling either the MII or GMII operation as appropriate for the data rate of the selected PHY. Most of the MII and GMII signals use the same names, but the width of the RXD and TXD data bundles and the semantics of the associated control signals differ between MII and GMII operation. The GMII transmit path clocking also differs significantly from MII clocking. MII operation of these signals and clocks is specified within Clause 22 and GMII operation is specified within Clause 35.
%GMII obsahuje 3ti zakladni registr Extended status reg(15)

\label[RMIIsub]

\secc Reduced Media Independent Interface

Reduced Media Independent Interface (RMII) je~obdoba rozhraní MII, která má ale snížený počet vývodů z~16 na~8 \cite[RMII].
Toto snížení je~zajištěno přidáním přemapující podvrstvy Reconsiliation Sublayer (RS).
Ta může nahradit stávající podvrstvu RS nebo může být připojena za~ni \cite[RMIIcon].

Připojenou podvrstvu RS za~stávající rozhraní lze vidět na~obrázku \ref[RMIIRS].

\medskip
\clabel[RMIIRS]{Rozšíření MII o~další RS.}
\picw=15cm \cinspic images/rmiirs.pdf
\caption/f Rozšíření rozhraní MII o~další podvrstvu RS. Obrázek převzat z~\cite[RMII].
\medskip

RMII používá stejné ovládací rozhraní jako MII definované standardem IEEE 802.3u~\cite[IEEE8023], který je~popsán v~sekci \ref[MDIOs].

Hlavními rozdíly RMII rozhraní oproti MII jsou datové signály TXD a~RXD. které jsou v~RMII rozhraní pouze 2 bity široké.
Dále signály COL a~CRS jsou zde sjednoceny do~jednoho signálu na~vývodu CRS\_DV.
Dalším rozdílem je~detekce kolizí, která je~na~vrstvě MAC provedena jako logický součin signálů TX\_EN a~CRS\_DV.
Zdrojem hodinového signálu je~vrstva MAC nebo je~generován externími hodinami.

	%DONE

% TODO
%\sec linux

%\sec info kernel

%\sec loading proces

%\sec disribuce

%\secc openwrt

\medskip \medskip \medskip \medskip

\label[LINUXsub]

\sec Subsystémy operačního systému Linux

Tato kapitola obsahuje informace o~tom, co to je~ovladač, a~dále popisuje základní stavební prvky poskytováné operačním systému Linux: device, net\_device, usb subsystém, usbnet, mii\_bus, DSA a~sysfs.

\secc Ovladač

Ovladač je~část programu (algoritmu), která spravuje nebo kontroluje určité zařízení připojené k~počítači.
Ovladače vytvářejí softwarové rozhraní pro~hardwarové zařízení, které umožňují operačnímu systému ovládat tento hardware, aniž by uživatel věděl, jak přesně funguje \cite[LDD3].

Linuxové jádro je~monolitický operační systém, a~proto ovladače zařízení jsou nahrány ve~stejném paměťovém prostoru jako samotné jádro.
Operační systém Linux umožňuje zavádět tyto ovladače dynamicky za~běhu systému nebo staticky při jeho kompilaci.

\secc Struktura device

Každé zařízení je~v~operačním systému Linux reprezentováno instancí struktury {\em device}.
Struktura device obsahuje informace o~tom, co zařízení potřebuje, aby správně fungovalo v~systému.
Mnoho subsystémů uchovává informace o~struktuře {\em device} a~tyto informace využívá k~dalším úkonům.
Většina zařízení není reprezentována pouze strukturou {\em device}.
Místo toho některé instance ve~struktuře {\em device}, jako je~kobj, obecně implementují zařízení, která jsou nadřazená struktuře {\em device} \cite[DEV]
\fnote{Popis datové struktury {\em device} lze nalézt na~\url{http://lxr.free-electrons.com/source/include/linux/device.h?v=3.19\#L730}}.

\label[NETDEV]

\secc Zařízení typu net device

Struktura {\em net\_device } popisuje síťové rozhraní jak fyzické tak virtuální (jako jsou VLAN)\cite[ULNI].
Síťové rozhraní může přijímat a~vysílat velké množství dat, a~proto je~implementace podobná diskovým zařízením \cite[LDD3].
Síťová zařízení přijímají data asynchronně a~ukládají je~do~vyrovnávací paměti.

V Linuxovém jádře je~síťový subsystém implementován tak, že je~na~protokolu nezávislý.


Jednotlivé položky struktury {\em net\_device } mohou být klasifikovány do~několika kategorií \cite[ULNI]:
\begitems
*Konfigurační položky -- část konfigurace je~automaticky naistalována Linuxovým jádrem a~je možné je měnit programy z~uživatelského rozhraní, jako je~ifconfig a~ip.
*Statistiky -- například statistiky jako počet odeslaných paketů a~paketů přijatých.
*Stav zařízení
*Správa přenosu -- nastavení kvality služeb (QoS).
*Tabulka virtuálních funkcí -- je tabulka ukazatelů implementovaných ovladačů zařízení. Obsahuje funkce jako je~aktivace a~deaktivace portů, nastavení adres a~mnohé další popsané v~dokumentaci Linuxového jádra nebo v \cite[ULNI].
\enditems


\label[USBst]

\secc USB subsystém

Linuxové jádro podporuje dva druhy USB ovladačů -- ovladače na~hostovském systému a~ovladače na~periferním zařízení \cite[LDD3].
USB ovladač na~hostovském systému pracuje na~systému, ke kterému je~USB zařizení připojeno.
Ovladač v~periferních zařízeních, neboli \uv{USB gadget drivers} kontroluje připojená zařízení přes USB.
Na obrázku níže můžeme vidět USB hierarchii datových struktur USB subsystému, kde USB zařízení může existovat v~několika různých subsystémech (net, block, char ...).
Jádro USB je část USB subsystému, která implementuje rozhraní pro~USB ovladače, které chtějí ovládat hardware a~přistupovat k~němu tak, jak můžeme vidět na obrázky \ref[USBH].

\medskip
\clabel[USBH]{Hierarchie USB subsystému.}
\picw=15cm \cinspic images/usbsub.pdf
\caption/f Hierarchie USB subsystému. Obrázek převzat z~\cite[LDD3].
\medskip

Koncové body USB jsou popsány v~jádře Linuxu strukturou {\em usb\_host\_endpoint}.
Tato struktura obsahuje informace o~reálném koncovém bodu připojeného zařízení ve~struktuře {\em usb\_endpoint\_descriptor}.
Struktura {\em usb\_endpoint\_descriptor} popisuje data pomocí přijatých deskriptorů.

\medskip
\clabel[USBMAP]{Hierarchie USB.}
\picw=15cm \cinspic images/usbendpmap.pdf
\caption/f Hierarchie USB popisuje, jak jsou zaobaleny jednotlivé části USB subsystému. Obrázek převzat z~\cite[LDD3]. 
%TODO XXX popisek
\medskip


USB rozhraní tak, jak můžeme vidět na obrázku \ref[USBMAP], je~složeno z~několika koncových bodů, které tvoří jedno logické připojení, jako je~napřiklad myš, klávesnice, video atd. %TODO XXX
Některá USB zařízení však mohou mít více rozhraní.
Například USB repoduktory mohou mít dvě rozhraní, jako je~USB klávesnice pro~tlačítka reproduktoru a~USB audio pro~jeho zvuk \cite[LDD3]. %TODO presunout nahoru
Linuxové jádro používá pro~každé rozhraní právě jeden ovladač.
Každé rozhraní je~popsáno strukturou {\em usb\_interface}.
Tato struktura obsahuje informace, které jádro USB předává USB ovladačům.

Každé zařízení může mít různé nastavení, které je~předáváno v~deskriptorech.
Linuxové jádro popisuje toto nastavení ve~struktuře {\em usb\_host\_config} a~celé USB zařízení strukturou {\em usb\_device}.
Jedno USB zařízení však může mít konfigurací více.
Konfigurace se~mohou v~průběhu práce zařízení měnit.
%Linuxové jádro ale nemůže obsluhovat více konfigurací v~jeden čas. %TODO XXX


Ovladače USB zařízení  obyčejně odkazují data ze struktury ~{\em usb\_interaface} do struktury ~{\em usb\_device}.

Subsystém sysfs (viz v sekci \ref[SYSFS]) umožňuje přístup ke strukturám {\em usb\_device} a~{\em usb\_interface}, které jsou zobrazeny jako složky a soubory.
Příklad cesty v sysfs reprezentující strukturu {\em usb\_device} může vypadat následovně:

\begtt  /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1  \endtt

K výše uvedené cestě k~USB zařízení je~na~zvýrázněném řádku USB rozhraní reprezentováno strukturou {\em usb\_interface}.
Tato struktura je~pojmenována podle formátu root\_hub-hub\_port:config.interface (pro hlubší stromy je~schéma root\_hub-hub\_port-hub\_port:config.interface):

\begtt /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1/2-1:1.0 \endtt

Pro komunikaci se~všemi USB zařízeními používá Linuxové jádro strukturu USB request block (URB).
URB definuje asynchronní typ komunikace, která slouží k~posílaní a~příjmu dat pro~specifický koncový bod USB a~specifické USB zařízení.

\label[USBNET]

\secc Subsystém usbnet

Usbnet je~subsystém Linuxového jádra, který umožňuje ovládat síťová zařízení jako je~Ethernet, DSL, IDSN atd.
%Usbnet je~obecná síťová nadstavba, která pracuje na~různých rychlostech a~nad různými protokoly.

Ovladač pro zařízení Asix AX88772b patří do třídy usbnet.
Na obrázku \ref[umlASIX] níže lze vidět UML diagram důležitých struktur pro~tento ovladač.

\medskip
\clabel[umlASIX]{Diagram tříd ovladače AX88772b.}
\picw=15cm \cinspic images/driver_asix.pdf
\caption/f Diagram tříd vybraných datových struktur v~subsystému usbnet.
\medskip

Na obrázku \ref[umlASIX] je~znázorněn subsystém usbnet obsahující vztahy mezi jednotlivými strukturami, které mají následující význam:
\begitems
*net\_device -- struktura reprezentující síťové rozhraní
*driver\_info -- struktura pro~ovladač usbnet zařízení
*usb\_device -- struktura reprezentující zařízení USB
\enditems


\secc Struktura mii bus

Struktura {\em mii\_bus} reprezentuje MII rozhraní.
Obsahuje tabulku virtuálních funkcí a~umožňuje přístup k~registrům popsaných v~sekci \ref[miireg].

\label[DSA]

\secc Subsystém Distributed Switch Architecture

Distributed Switch Architecture (DSA) je~subsystém pro~správu hardwarových Ethernetových přepínačů \cite[DSA].
%Obsahuje MII menežovací registry, příkazy pro~nastavení přepínače a~formát ethernetových hlaviček, který signalizuje na~kterém portu byl paket přijat nebo ktery se~hodlá odeslat 
Tento subsystém podporuje přepínače, které jsou připojeny způsobem zobrazeným na~obrázku \ref[DSAcon].

\medskip
\clabel[DSAcon]{Připojení přepínače k~CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon.pdf
\caption/f Možné připojení Ethenetového přepínače k~procesoru, které využívá subsystém DSA. Obrázek je~převzat z~\cite[DSA].
\medskip

DSA subsystém interpretuje každý port přepínače jako oddělené síťové rozhraní popsané v sekci \ref[NETDEV].
Konfigurace přepínače, jako je~nastavení portů a~správa MII rozhraní, se děje na~základě struktury ukazatelů na funkce {\em ethtool\_ops}, kterou využívá například nástroj Ethtool \fnote{Ethtool je~standardní nástroj Linuxu pro~ovládání a~podporu ovladačů a~zařízení \cite[EMBLINUX].}.

Subsystém DSA podporuje i propojení mezi přepínači tak, jak je~možno vidět na~obrázku \ref[DSAcon2].
Takto propojené přepínače lze ovládat skrz MII rozhraní. %TODO XXX skrz mii neni na obrazku a je jich tam nekolik???

\medskip
\clabel[DSAcon2]{Připojení více přepínačů DSA k~CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon2.pdf
\caption/f Možné připojení DSA přepínačů k~procesoru. Obrázek je~převzat z~\cite[DSA].
\medskip

Na obrázku \ref[umlDSA] je~diagram tříd důležitých struktur v~subsystému DSA, které jsou nezbytné pro~funkčnost subsystému.

\medskip
\clabel[umlDSA]{Diagram tříd DSA subsystému.}
\picw=15cm \cinspic images/dsa_uml.pdf
\caption/f Diagram tříd vybraných datových struktur DSA subsystému.
\medskip

Na tomto obrázku \ref[umlDSA] jsou zvýrazněny struktury {\em mii\_bus}, {\em net\_device} a~{\em dsa\_platform\_data}.
Tyto struktury DSA subsystém nevytváří, a~proto je~potřeba je~předat subsystému způsobem, který je~popsán v~kapitole \ref[ARCH] Implementace.

%XXX upravit aby to bylo více vypovídající
Instance subsystému DSA je~reprezentována strukturou {\em dsa\_switch\_tree}, která obsahuje odkazy na~struktury:
\begitems
*dsa\_platform\_data -- tato struktura obsahuje informace o~kořenovém zařízení.
Také obsahuje strukturu {\em dsa\_chip\_data} popsanou níže.
*net\_device -- tato struktura odkazuje na~hlavní síťové zařízení ( viz sekce \ref[NETDEV] ), která obsahuje informace o použitém protokolu.
*dsa\_switch -- obsahuje data pro~jednotlivé přepínače:
\begitems
*dsa\_switch\_tree -- je~odkaz na~rodičovskou strukturu.
*dsa\_chip\_data -- struktura obsahující informace o~fyzickém přepínači -- kolik má portů a~jaké jsou jejich názvy.
Navíc obsahuje informace o~popisu hardwaru ve~zkompilovaném device tree
\fnote{Device tree je~struktura, předávána zavaděčem operačního systému, která popisuje připojení hardwaru. A tak odlehčuje kódu, který by popisoval každý detail. \cite[DT].}.
*device -- je~odkaz zařízení přepínače.
*dsa\_switch\_driver -- struktura popisující ovladač přepínačů, obsahuje funkce na~správu připojeného přepínače.
V~jádře se~struktura obsahující odkazy na~funkce označuje jako tabulka virtuálních funcí \cite[ULNI].
*mii\_bus -- je~ovladač MII sběrnice.
*net\_device -- je~odkaz na~síťové zařízení reprezentující port zařízení.
\enditems
\enditems





\label[SYSFS]

\secc Souborový systém sysfs

Souborový systém sysfs je~obsažen v Linuxovém jádře od verze 2.6.
Umožňuje jádru operačního systému exportovat informace do~uživatelského prostoru za~použití paměti \cite[SYSFS]. %TODO XXX VFS ??
Hlavním účelem je~reprezentovat objekty jádra, jejich atributy a~jejich vzájemné vztahy.
Většina atributů je~reprezentována textovými soubory, které jsou~v~kódování ASCII a~obsahují pouze jednu hodnotu.
Sysfs poskytuje dvě rozhraní k reprezentování dat:

\begitems
*kernel programming interface -- slouží k~exportování a~importování položek (viz níže) skrz sysfs do~jádra.
*user interface -- slouží k~zobrazení a~manipulaci s~těmito položkami (viz níže), které mapuje zpět na~objekty v~jádře.
\enditems

Mapování objektů a~atributů na objekty v sysfs můžeme vidět v~tabulce \ref[SYSFSmap].

\midinsert \clabel[SYSFSmap]{Mapováni objektů a~atributů v~sysfs.}
\ctable{ll}{
 \hfil  Interní   & Externí  \crl \tskip4pt
        Jaderné objekty    & Složky  \cr
        Atributy objektů     & Soubory  \cr
        Vazby mezi objekty   & Symbolické odkazy  \cr
}
\caption/t  Tabulka popisující mapování objektů a~atributů z~jádra. Tabulka převzata z~\cite[SYSFS].
\endinsert

Sysfs je připojen do složky {\em /sys/}.
Složka /sys/ může vypadat následovně:
\begtt
    /sys/
    |-- block
    |-- bus
    |-- class
    |-- devices
    |-- firmware
    |-- module
    ‘-- power
\endtt

Sysfs je~reprezentováno v~Linuxovém jádře jako struktura {\em kerfs\_root}, která se skládá z~uzlů {\em kernfs\_node}.
Tyto struktury využívají instance struktur kobj k reprezentaci dat, a také obsahují tři druhy obslužného volání -- na~zápis, čtení a~na uvolnění.

\label[pouzhw]


\chap Použitý hardware

Tato kapitola popisuje použitý procesorový modul, na~kterém byl provaděn vývoj ovladačů, desku konfigurovatelného přepínače a~čipy, které jsou na~této desce použity.

\label[T20]

\sec Procesorový modul Colibri T20

Modul Colibri T20, vyráběný firmou Toradex \cite[TODADEX], je~počítačový modul založen na~NVIDIA Tegra 2 vestavěném systému na~čipu \cite[SOC].
Tento modul dále obsahuje 256~MB DDR2 paměti a~512~MB NAND flash paměti.
Má velké množství komunikačních rozhraní, jako je~I2C, SPI, UART, MMC, USB a Ethernet a~výstup pro PWM.
Také obsahuje audio a~video výstup.
Čip obsahuje periferie popsané v~blokovém diagramu na~obrázku \ref[SOC].

\medskip
\clabel[SOC]{Colibri T20 blokový diagram.}
\picw=15cm \cinspic images/soc.pdf
\caption/f Procesorový modulu Colibri T20. Obrázek převzat z~\cite[SOC].
\medskip

Firma Toradex dodává k~tomuto modulu podporu pro~Linuxové jádro verze 3.1.10.

\sec Systém na~čipu NVIDIA Tegra 2

Systém na~čipu NVIDIA Tegra 2 od firmy NVIDIA je~založen na~dvoujádrovém procesoru Cortex A9 se~symetrickým procesorovým jádrem s~frekvencí okolo 1~GHz \cite[TEGRA2].
Jelikož se~jedná o~systém na~čipu, obsahuje tento čip mnoho bloků, jako je~například Audio/Video rekordér, grafický procesor s~podporou 2D rendrovaní a~3D pixelové a~vektorové shadery.
Tento systém na~čipu dosahuje vysokého grafického i výpočetního výkonu, viz \cite[BENCH].

Procesor Cortex A9 má 32-bitovou RISC
\fnote{Architektura RISC označuje procesory s~redukovanou instrukční sadou.}
architekturu vyvinutou společností ARM Holding věnující se~vývoji procesorových jader.
Tento procesor podporuje out--of--order a~spekulativní provádění instrukcí.
Má plnou podporu koherence pamětí pro~symetrické procesory.
Procesor též obsahuje jednotku pro~výpočty s~plovoucí řádovou čárkou.

Bloky systému na~čipu NVIDIA Tegra 2 lze vidět na~obrázku níže \ref[TEGRA].

\medskip
\clabel[TEGRA]{Bloky systému na~čipu NVIDIA Tegra 2.}
\picw=15cm \cinspic images/tegra2.pdf
\caption/f Bloky procesoru NVIDIA Tegra 2. Obrázek převzat z~\cite[TEGRA].
\medskip

\label[ASIX]

\sec USB--Ethernet kontrolér Asix AX88772b


AX88772b je~zákaznický integrovaný obvod vyráběný firmou Asix, který umožňuje připojení Fast Ethernet rozhraní za běhu systému.
To je určeno pro~zařízení disponující hostitelským rozhraním USB verze 1.1 nebo verze 2.0.


Jako jediný z~vyráběných modelů dosahuje v~revizi AX88772b teplotních rozsahů od~ $-40$ do~$+85^{\circ}C$. Což odpovídá průmyslovým teplotním rozsahům.
AX88772b má modifikovatelnou vícefunkční sběrnici, která umožňuje připojit RMII rozhraní, popsané v sekci~\ref[RMIIsub], nebo Reverse-RMII způsobem MAC--to--MAC k~mikrokontroléru s~Ethernet MAC RMII rozhraním.
MAC rozhraní je~plně kompatibilní se~standardy IEEE~802.3, IEEE~802.3u.

%TODO ASIX
\medskip
\clabel[ASIXcip]{Blokový diagram AX88772b.}
\picw=15cm \cinspic images/asix_conn.pdf
\caption/f Blokový diagram čipu AX88772b od firmy Asix. Obrázek je~převzat z~\cite[ASIX].
\medskip
%jake umoznuje propojeni po rmii?

Jak je~vidět na~obrázku \ref[ASIXcip], čip AX88772b obsahuje Ethernetovou vrstvu PHY, která však nemůže být aktivní současně s~RMII rozhraním.
Dále obsahuje periferii pro~připojení EEPROM paměti a~nastavitelné vývody, nejčastěji používáné pro~připojení LED diod.
Tento čip též obsahuje regulátor napětí z~3,3~V na~1,8~V.



\label[MARVELL]

\sec Ethernetový přepínač Marvell 88E6065

Marvell 88E6065 je~5~+~1 portový Ethernetový přepínač integrovaný na~čipu.
Obsahuje  pět portů s~fyzickou vrstvou 10~BASE-T/100~BASE-TX, z~nichž dva porty mohou být využity pro~optickou linku 100~BASE-FX.
Navíc obsahuje port, pro~připojení MAC vrstvy pomocí RMII nebo MII rozhraní.
Též jde připojit pouze přes ovládací rozhraní z~MII.
Zařízení má vysokorychlostní neblokující čtyřúrovňový QoS
\fnote{QoS umožňuje síti, garantovat lepší kvalitu služeb. A umožňuje aplikacím požadovat a~přijímat předvídatelné úrovně těchto služeb, aby zvýšili průtok sítě a~její odezvu. \cite[CISCO].}.

Vrstva PHY tohoto zařízení podporuje plug--and--play s~možností automatického určení směru, automatického určení polarity a~automatického určení rychlosti.
Zařízení dále podporuje 64 z~4096 802.1Q WLAN s~3 úrovňovou ochranou.
Obsahuje dvě RMII/MII/SNI rozhraní, která mohou být připojena k~ovládacímu rozhraní nebo ke~kontroléru s~integrovanou vrstvou  MAC.
MAC a~PHY vrstvy jsou plně kompatibilní se~standardy IEEE~802.3, IEEE~802.3u a~IEEE~802.3x.

Zařízení může být konfigurováno přes ovládací rozhraní nebo může načítat nastavení z~EEPROM paměti.

%Výjimečně se~přepínač Marvell 88E6065 může využívat jako směrovač či výchozí brána.
%jake umoznuje porjojeni RMII
\medskip
\clabel[MARVELL6060]{Blokový diagram 88E6060.}
\picw=15cm \cinspic images/6060conn.pdf
\caption/f Zapojení systému s čipem 88E6060 od firmy Marvell, které je~velmi podobné zapojení čipu 88E6065. Obrázek je~převzat z~\cite[MARVELL].
\medskip

Jak lze vidět na~obrázku \ref[MARVELL6060], který popisuje obvod Marvell 88E6060, který je~velmi podobný obvodu Marvell 88E6065.
Oba tyto modely potřebují externí hodinový krystal a~zdroj napětí.

\label[SWITCH]

\sec Deska konfigurovatelného přepínače


Deska konfigurovatelného přepínače byla vyrobena firmou Retia a.s.
\fnote{Firma zabývající se~elektronickými vojenskými systémy, záznamovými zařízeními a~lokalizačními a~bezpečnostními systémy. \url{www.retia.cz}}
na základě jejich návrhu a~zapojení, ktará jsou popsaná v~přílohách \ref[zapojeni1], \ref[zapojeni2].

Tato deska byla vyrobena za~účelem nahrazení staršího modelu konfigurovatelného přepínače, který splňuje průmyslové teplotní rozsahy, za~výkonnější.

Zjednodušené schéma této desky je~znázorněno na~obrázku \ref[deska].

\medskip
\clabel[deska]{Blokové schéma desky konfigurovatelného přepínače.}
\picw=15cm \cinspic images/diagdeska.pdf
\caption/f Blokové schéma zapojení desky konfigurovatelného přepínače.
\medskip

Konfigurovatelný přepínač umožňuje nastavení Ethernetového přepínače za~pomoci USB Ethernet kontroléru AX88772b od firmy Asix \ref[ASIX], ke kterému je~připojena externí pamět EEPROM M93-C66 \fnote{Popsané na~\url{http://www.st.com/web/catalog/mmc/FM76/CL1276/SC112/PF63995?referrer=70071840}}.
Tento kontrolér je~připojen přes RMII rozhraní k~čipu Marvell 88E6065 \ref[MARVELL], viz na~obrázku níže \ref[MARVELL6065rmii].

\medskip
\clabel[MARVELL6065rmii]{Zapojení RMII k~čipu Marvell 88E6065.}
\picw=10cm \cinspic images/marvellrmii2.pdf
%\picw=10cm \cinspic images/rmii.pdf
\caption/f Připojení RMII rozhraní mezi zařízeními Marvell 88E6065 a Asix AX88772b. Obrázek upraven podle~\cite[MARVELL].
\medskip

I k~tomuto čipu je~připojena externí pamět EEPROM.

Oba čipy Asix AX88772b a~Marvell 88E6065 mají vlastní krystal s~frekvencí 25~MHz.
Deska je~navíc osazena regulátorem napětí a~přepínači pro~různá nastavení MII rozhraní,
%(K3 a~K2), resetování (K5) a~externí vzbuzení (K4), 
jak je~možno vidět v~příloze \ref[zapojeni1].

\label[impl]

\chap Implementace

Tato kapitola popisuje portaci Linuxového jádra verze 3.19 pro~modul Colibri T20 \ref[T20], která byla zapotřebí pro~další implementaci ovladačů.
Dále se~zabývá způsobem oživení desky konfigurovatelného přepínače \ref[SWITCH] a~následným popisem tvorby ovladače pro~tento přepínač \ref[ARCH] a~jeho implementace \ref[ZPRAC].

Vývoj byl prováděn na~vývojovém kitu s~modulem Colibri T20.
Pro vývoj ovladače bylo zvoleno jádro z~upstreamové větve Linuxového jádra
\fnote{Linuxové jádro je~možné stáhnout na~\url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git}}.
Práce byla započata s~verzí Linuxového jádra 3.17, a~později aktualizována na~verzi 3.19.

%TODO XXX check

\label[UPSTREAM]

\sec Portace Linuxového systému

Pro portaci hlavní větve Linuxového jádra bylo vyžadováno několik nástrojů a~programů pro~překlad kódu, jako je kompilátor pro architekturu ARM, v našem připadě použit kompilátor linaro
\fnote{Linaro TODO XXX},
který též obsahuje linker, jež je využíván pro slinkování přeložených kódů.
Dále je potřeba nástroj pro verzování git a nástroj pro kontrolu generování spustitelných souborů -- make.

Byla zvolena novější verze jádra, než kterou podporuje Toradex, a tou je verze 3.1.10.
Důvodem byla komunikace s vývojáři hlavní větve Linuxového jádra a následné poslání patche.

\secc Zavaděč U-Boot

Jako první krok bylo potřeba nainstalovat zavaděč, který by se~postaral o~zavedení Linuxového jádra na~modul Colibri T20.
Pro tento úkol byl zvolen zavaděč U-Boot
\fnote{U-Boot je~možný stáhnout z~repozitáře \url{git://git.denx.de/u-boot.git}},
který je~využíván i výrobcem modulu Colibri T20, avšak byla zvolena jeho novejší verze.

V tomto kroku bylo nutné stáhnout a~zkompilovat nejnovější zavaděč.
Jako konfigurační soubor byl zvolen {\em colibri\_t20\_iris\_config}, který popisuje modul Colibri T20 s~vývojovou deskou Iris.

\begtt
> export CROSS_COMPILE=~/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
> export ARCH=arm
> git clone git://git.denx.de/u-boot.git
> make colibri_t20_iris_config
> make -j8
\endtt

Dále bylo potřeba stáhnout nástroj, který by sloužil k~vytvoření cílového binárního souboru zavaděče U-Boot.
Ten využívá configurační soubory od firmy Toradex, které se spojí s přeloženým zavaděčem, které zkopírujeme do kořenového adresáře nástroje cbootimage.

\begtt
> git clone https://github.com/NVIDIA/cbootimage-configs.git
> cd cbootimage-configs
> cbootimage -gbct -t20
		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.bct.cfg
 		colibri-t20_512_v12_nand.bct
> cp ~/PATH/u-boot/u-boot-dtb-tegra.bin u-boot.bin
> cbootimage -t20
 		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.img.cfg
 		colibri-t20_512_v12_nand.img
\endtt

Poté byl zavaděč zaveden z~diskového souboru následujícím příkazem:

\begtt
> tegrarcm --bct colibri-t20_512_v12_nand.bct --loadaddr=0x00108000
 		--bootloader=../u-boot/u-boot-dtb-tegra.bin
\endtt

Po zavedení tohoto zavaděče bylo možné sledovat, jak se~na konzoli modulu Colibri T20 zobrazil výpis tohoto zavaděče.
A za~pomoci USB-Ethernetového kontroléru, který byl integrovaný na~modulu, byl nahrán obraz zavaděče do~paměti RAM modulu.

\begtt
Tegra20 (Colibri) # usb start
(Re)start USB...
USB1: USB EHCI 1.00
scanning bus 1 for devices... 1 USB Device(s) found
USB2: USB EHCI 1.00
scanning bus 2 for devices... 2 USB Device(s) found
 scanning usb for storage devices... 0 Storage Device(s) found
 scanning usb for ethernet devices... 1 Ethernet Device(s) found
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot 0x02100000 colibri-t20_512_v12_nand.img
Waiting for Ethernet connection... done.
TFTP from server 192.168.80.3; our IP address is 192.168.80.90
Filename 'colibri-t20_512_v12_nand.img'.
Load address: 0x02100000
Loading: #################################
         3.6 MiB/s
done
Bytes transferred = 729088 (b2000 hex)
\endtt

Bylo nutné nahrát obraz zavaděče do~paměti NAND a~přepsat původní zavaděč současným.
Délka přeneseného obrazu byla 0xb2000, viz výpis výše.
Tato hodnota byla potřeba k~určení délky přepisovaného úseku NAND paměti.

\begtt
Tegra20 (Colibri) # nand erase.chip

NAND erase.chip: device 0 whole chip
Erasing at 0x3ffc0000 -- 100% complete.
OK
Tegra20 (Colibri) # nand write 0x02100000 0 0xb2000

NAND write: device 0 offset 0x0, size 0x95000
 577536 bytes written: OK
\endtt

Po resetu zařízení byl na sériové konzoli vidět výpis aktualizovaného zavaděče U-Boot, který ale v~tento moment nebyl schopen nalézt žádné jádro operačního systému.
Jádro bylo přidáno v~dalším kroku popsaném v~sekci \ref[LINUXkernel].

\label[LINUXkernel]

\secc Linuxové jádro

Následujícím krokem  byla instalace aktuální verze jádra, která byla nutná k~vývoji ovladačů a~komunikaci s~Linuxovou komunitou.
Jelikož upstreamové jádro nepodporuje řadič NAND paměti, který je součástí čipu Colibri T20, načítání tohoto jádra bylo realizováno přes Ethernetovou síť \cite[UPLINUXT20].

Pro~instalaci Linuxového jádra bylo potřeba stáhnout a~přeložit verzi 3.19 \cite[UPLINUXT20].
Pro~nastavení jádra byla zvolena konfigurace {\em tegra\_defconfig}, která obsahuje moduly a~ovladače potřebné pro~jeho běh.

\begtt
> git clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
> cd linux
> git checkout v3.19
> export LOADADDR=0x408000
> export ARCH=arm
> export CROSS_COMPILE=/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
> make tegra_defconfig
> make -j8 uImage
\endtt

Po přeložení verze 3.19 bylo potřeba nahrát obraz jádra a~přeloženého device tree\fnote{Device tree je~struktura, předávána zavaděčem operačního systému, která popisuje připojení hardwaru. A tak odlehčuje kódu, který by popisoval každý detail. \cite[DT].}
do~RAM paměti modulu za pomoci příkazů pro zavaděč U-Boot po~sériové lince následujícími příkazy:

\begtt
Tegra20 (Colibri) # usb start
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot ${kernel_addr_r} uImage
Tegra20 (Colibri) # tftpboot ${fdt_addr_r} tegra20-iris-512.dtb
\endtt
%Load address: 0x1000000 kernel
%Load address: 0x2000000 dbt

Po nahrání obrazů  byly nastaveny parametry pro~Linuxové jádro
\fnote{\url{https://www.kernel.org/doc/Documentation/kernel-parameters.txt}},
tedy nastavení konzole, jejího portu a~rychlosti, dále pak nastavení oddílu s~distribucí a~jejího typu souborového systému.
Pokud v~nastaveném oddílu bude obraz souborového systému s~nainstalovanou Linuxovou distribucí, jádro tuto distribuci zavede.

\begtt
Tegra20 (Colibri) # set bootargs console=ttyS0,115200n8 earlyprintk
		root=/dev/mmcblk0p1 rootfstype=ext2 rw rootdelay=1
Tegra20 (Colibri) # bootm ${kernel_addr_r} - ${fdt_addr_r}
\endtt

\sec Zavedení Linuxové distribuce OpenWrt

> git clone git://git.openwrt.org/openwrt.git




\sec Oživení desky přepínače

Pro oživení desky byl nejprve testován USB kontrolér Asix AX88772b, viz sekce \ref[oAX].
Po oživení komunikačního rozhraní tohoto kontroléru bylo dalším krokem ladění Ethernetového přepínače Marvell 88E6065, viz sekce \ref[oMV].
Nakonec bylo provedeno testování Ethernetových portů přepínače.
V průběhu tohoto testování bylo objeveno několik chyb v~návrhu desky, které byly na~základě mých připomínek opraveny.

\label[oAX]

\secc Oživení USB--Ethernet kontroléru Asix AX88772b

%jak jsi oživoval Asix?
V průběhu oživování USB kontroléru byla objevena závada v~jeho připojení na~desce konfigurovatelného přepínače.
Tato závada se~projevovala chybnou komunikací na~USB sběrnici, která byla objevena při použití modulu Colibri T20.
Tato chybná komunikace je~znázorněna na~obrázku \ref[usbbuserr].
Je zde znatelné, že pakety, které dorazily k~hostovskému zařízení, modul příjímal poškozené.

\medskip
\clabel[usbbuserr]{Chybná komunikace na~USB sběrnici.}
\picw=15cm \cinspic images/wrong_com_wire.pdf
\caption/f Záznam chybné komunikace na~USB sběrnici mezi PC a~USB kontrolérem Asix AX88772b, která byla zaviněna nepřipojením blokovacího kondenzátoru.
\medskip

Po úpravě zapojení začal USB kontrolér odpovídat na~dotazy aktuálního ovladače v~operačním systému Linux.
To bylo možné ověřit z~uživatelského prostoru příkazem:
\begtt
lsusb
\endtt


\medskip
\clabel[ASIXRMII]{Připojení RMII k~USB kontroléru Asix AX88772b.}
\picw=15cm \cinspic images/asix_rmii.pdf
\caption/f připojení vrstvy PHY, popřípadě rozhraní RMII. Obrázek převzat z~\cite[ASIX].
\medskip

Z obrázku \ref[ASIXRMII] lze vyčíst, že kontrolér AX88772b není schopen komunikovat po rozhraní PHY a~RMII současně.
Zápisem do~registru číslo 0 \cite[ASIXman] je~aktivováno právě jedno z~daných dvou rozhraní a~též musí být správně nastanena spojka K2, viz \ref[zapojeni1], která určuje funkčnost víceúčelových vývodů.

%Posledním krokem k~oživení USB kontroléru Asix AX88772b bylo nastavení vhodného chování tak, aby bylo zprovozněno rozhraní RMII, které je~blíže popsané v~\ref[ZPRAC].

\label[oMV]

\secc Oživení Ethernetového přepínače Marvell 88E6065

K oživení Ethernetového přepínače Marvell 88E6065 bylo zapotřebí aktivovat RMII rozhraní a~provést několik zásahů do~zapojení čipu na~desce.
Taktéž bylo zapotřebí aktivovat funkční komunikaci přes kontrolér Asix AX88772b, jak je popsané v sekci \ref[oAX], který na~základě USB příkazů je~schopen posílat ovládací zprávy přes RMII rozhraní.
Navíc bylo potřeba vyřešit, v~jakém módu bude tento Ethernetový přepínáč připojen.
Pro~připojení přepínače bylo zvoleno připojení MAC-to-MAC, ve~kterém hodinový signál pro~signál MDIO vysílá zařízení AX88772b a~hodiny o~frekvenci 50~MHz pro~RMII rozhraní Ethernetový přepínač Marvell 88E6065.
Zapojení je~znázorněno na~obrázku \ref[MARVELL6065rmii].

Protože i v zapojení čipu byla nalezena chyba v~komunikaci, byly doplněny chybějící blokovací kondenzátory.
Navíc byl objeven problém, že  tento čip se~po každém zapnutí nastavil do~odlišných nastavení.
Pro vyřešení tohoto problému byl k~čipu doplněn kondenzátor, který zařízení opakovaně resetoval po dobu časové konstanty RC.

Deska tak měla během této doby možnost, aby se~vstupní hodnoty na~všech vývodech ustálily ve~správném stavu.

Pro zajištění správného a~deterministického chování přepínače byly přidány pull-up a~pull-down rezistory viz \ref[zapojeni2].
\begitems
*pull up rezistor -- vývod SW\_MODE, ADDR4, P5\_MODE0, P5\_MODE1 a~P5\_MODE3
*pull down rezistor -- vývod P5\_MODE2
\enditems

\label[ARCH]

\sec Návrh subsystému

%TODO XXX

Pro dané zadání bylo potřeba vytvořit subsystém, který by propojoval ovladač Ethernetového přepínače Marvell 88E6065 se subsystémem DSA a s ovladačem pro kontrolér Asix AX88772b.

Cílem návrhu bylo propojení těchto částí tak, aby dodaná deska konfigurovatelného přepínače byla podporována operačním systémem Linux a aby tento přepínač bylo možno nastavit z uživatelského prostoru operačního systému.

Za tímto účelem bylo nejdříve potřeba rozšířit ovladač Asix AX88772b o podporu RMII rozhraní, které nebylo naimplementováno v operačním systému Linux, a o možnost připojení k subsystému DSA.
To bylo vyřešeno vytvořením souboru s obslužnou rutinou v souborovém systému sysfs.
Tato obslužná rutina aktivuje RMII rozhraní, přidělí potřebnou paměť a nastaví ji pro subsystém DSA a následně inicializuje  tento subsytém.
Navíc byla rozšířena uvolňovací funkce ovladače.
Kromě uvolňění samotného ovladače také volá uvolnění subsytému DSA.
Toto rozšíření bylo provedeno z důvodu navrácení přidělené paměti operačnímu systému.

Dalším krokem byla úprava subsystému DSA.
Tento subsystém vytváří každému portu Ethernetového přepínače rozhraní viditelné z uživatelského prostoru operačního systému a připojuje k nim příslušný ovladač pro daný Ethernetový přepínač.
Tento sybsystém bylo potřeba rozšířit o schopnost uvolňování a alokace za běhu.

Následovalo vytvoření ovladače Marvell 88E6065.
Tomuto ovladači byla přidána schopnost nastavit požadované chování Ethernetového přepínače a komunikovat skrz~USB kontrolér.

Nakonec operační systém Linux zajistí, aby ovladače spolu komunikovaly a aby byl po připojení USB kontroléru a inicializaci subsystému DSA přiřazen správný ovladač Ethernetového přepínače.

%Celý ovladač by měl podle návrhu fungovat tak, že při připojení USB zařízení se~zavede ovladač pro~zařízení AX88772b.
%V tomto případě je~to ovladač specifikovaný strukturou driver\_info a~konkrétní instance se~nazývá ax88772b\_info.
%Tato instance je~v~současné době naimplementována ve verzi 3.19 Linuxového jádra.
%Instance pomocí funkce asix88772\_bind inicializuje ovladač tak, že ten aktivuje PHY rozhraní a~vytvoří nové rozhraní pro~ethernetovou komunikaci přes net\_device strukturu a~ethtool\_ops a~net\_device\_ops funkce.

%Do návrhu byla doplněna funkce, která by měla vytvořit soubor v~systému sysfs\ref[SYSFS].
%Za pomoci obslužné rutiny vytvořeného souboru by měl být ovladač zařízení spojen s~DSA subsystémem.
%Tato rutina by měla předat DSA subsystému instance struktur net\_device, mii\_bus a~informace o~portech přepínače ve~strutuře dsa\_platform\_data.
%Všechny tyto instance nebo jejich odkazy by měla předat DSA subsystému struktura platform\_device.
%Zmíněné struktury lze vidět na~obrázku \ref[umlDSA].

%Za pomoci těchto dat by se~v~DSA subsystému měl vytvořit ovladač pro~přepínač.
%Ovladač by si pak měl najít potřebné funkce pro~konkrétní přepínač specifikovaný strukturou dsa\_switch\_driver a~pro každý port by měl vytvořit nové vlastní síťové rozhraní.

%Proces uvolňování ovladače z~paměti by měl být řešen funkcí dsa\_remove. Ta by měla uvolnit celý subsystém DSA i na~něm závislé instance, jako jsou síťová rozhraní.
%Při odpojení desky od modulu by měl toto uvolnění poskytovat USB ovladač Asix AX88772b.

\label[ZPRAC]

\sec Zpracování

Sekce zpracování popisuje provedení jednotlivých částí ovladače podle návrhu popsaném v předchozí sekci \ref[ARCH].

Jelikož nebyl ovladač pro~zařízení Asix AX88772b připraven na~připojení RMII rozhraní, bylo zapotřebí tento ovladač rozšířit  o~aktivaci rozhraní.
To však nemůže být aktivní současně s~rozhraním Ethernet PHY, které je~taktéž integrováno na~čipu, jak je~zobrazeno na~obrázku \ref[ASIXRMII].
To bylo provedeno zapsáním dat do~registru označeném SW\_PHY\_SELECT, který aktivoval druhé rozhraní.
Dále bylo potřeba zaregistrovat strukturu mii\_bus, která bude sloužit k ovládání RMII rozhraní tohoto kontroléru.

Poté bylo potřeba upravit subsystém DSA tak, aby podporoval inicializace zařízení za~běhu a jeho odhlašování a~uvolňování.
Posledním krokem bylo vytvoření samotného ovladače pro~zařízení Ethernetového přepínače Marvell 88E6065, který řeší jeho funkčnost.

\label[asixdri]

\secc Změna ovladače zařízení Asix AX88772b

Ovladač zařízení Asix AX88772b je~již přítomen v~Linuxovém jádře.
Ale jeho verze neměla implementovanou podporu rozhraní RMII, proto bylo potřeba doplnit ovladač o aktivaci tohoto rozhraní.

Byla zvolena možnost, že aktivace RMII rozhraní bude provedena přes zápis do~souboru {\em usb\_dsa\_bind}, který je~součástí souborového systému sysfs a~je umístěn ve~složce DSA\_BIND, která je podsložkou USB zařízení.
Tímto zápisem do souboru se nejen aktivuje RMII rozhraní, ale také se provede navázání se subsystémem DSA.

Vytvoření složky, která obsahuje zmíněný soubor, lze vidět na kódu níže:
\begtt
1   priv->kobj.kset = kset_create_and_add("DSA_BIND", NULL,
                         kobject_get(&dev->udev->dev.kobj));
2   if (!priv->kobj.kset){
3      ret = -ENOMEM;
4      goto free;
5   }
6
7   ret = kobject_init_and_add(&priv->kobj, &dsa_bind_ktype,
                         NULL, "dsa_bind");
8   if (ret)
9      goto free_kobj;
\endtt

Na řádku 7 tohoto kódu se v instanci {\em dsa\_bind\_ktype} struktury {\em kobj\_type} předávají atributy a operace obslužné rutiny pro zápis a čtení ze souboru.

Popis struktur popisující atributy a operace souboru {\em usb\_dsa\_bind}, který obsahuje obslužnou rutinu, lze vidět níže.

\begtt
1   static struct asix_attribute asix_attribute =  __ATTR(usb_dsa_bind, 0664, usb_dsa_show, usb_dsa_store);
2   static struct attribute *asix_default_attrs[] = {
3      &asix_attribute.attr,
4      NULL,
5   };
6   static const struct sysfs_ops dsa_bind_sysfs_ops = {
7      .show   = usb_dsa_attr_show,
8      .store  = usb_dsa_attr_store,
9   };
10  static struct kobj_type dsa_bind_ktype = {
11     .sysfs_ops      = &dsa_bind_sysfs_ops,
12     .release        = driver_release,
13     .default_attrs  = asix_default_attrs,
14  };
\endtt

Po zápisu do~tohoto souboru byla vyvolána obslužná rutina {\em usb\_dsa\_store()}, jejíž ukazatel byl nainicializován v průběhu inicializace ovladače Asix AX88772b opsané výše.

Tato rutina následně vyvolala funkci {\em ax88772\_set\_bind\_dsa()}, která vypadá následovně:

\begtt
1   static int ax88772_set_bind_dsa(struct asix_common_private *priv)
2   {
3      struct usbnet *dev = priv->dev;
4      int i, ret, embd_phy;
5      u32 phyid;
6      int temp = AX88772_RMII;
7
8      /* Enable RMII interface for external PHY */
9      asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT, 0, 0, 1, &temp);
10
11     for (i = 0; i < AX88772_MAX_PORTS; i++) {
12        phyid = asix_mdio_read(dev->net, i, 0x3);
13        if (phyid == MV88e6065_ID)
14           break;
15     }
16
17     if (phyid == MV88e6065_ID) {
18        ret = ax88772_init_mdio(dev);
19        if (ret)
20           return ret;
21
22       priv->use_embphy = 1;
23
24       priv->pdev = dsa_create_pdev(priv->mdio, dev->net);
25       if (priv->pdev == NULL)
26          return -ENOMEM;
27
28       ret = dsa_probe_net_device(priv->pdev, dev->net);
29       if (ret)
30          return ret;
31    }
...
\endtt


Nejprve tato funkce aktivuje RMII rozhraní zapsáním do registru, jak lze vidět na~řádku~9.
Na řádcích 11 až 15 je znázorněna její další funkce, a to testování, zda bylo k~USB kontroléru připojeno zařízení Marvell 88E6065 dle standardizováného registrového prostoru, viz obrázek \ref[miireg], konkrétně vyčtením z registru číslo 3.
Ten obsahuje identifikátor a~revizi zařízení.
Pokud bylo objeveno zařízení Marvell 88E6065, tato funkce navíc vyplní strukturu {\em asix\_common\_private} a následně zavolá funkci {\em dsa\_probe\_net\_device}.

Struktura {\em asix\_common\_private} ve~verzi jádra 3.19 obsahuje následující prvky:

\begitems
*kobject -- struktura popisující objekt v souborovém systému sysfs.
*mii\_bus -- struktura odkazující na komunikační rozhraní USB.
*use\_embphy -- příznak informující o typu použitého rozhraní (RMII nebo PHY).
*dsa\_up -- příznak informující o použití subsystému DSA.
*usbnet -- struktura odkazující na zařízení Asix AX88772b.
*platform\_device -- struktura popisující Ethernetový přepínač, jako je počet portů a jejich názvy.
Je naplněná ve funkci {\em dsa\_crete\_pdev}.
\enditems

%Ve verzi linuxového jádra 3.19 subsystém DSA byl upraven a~nevyžaduje strukturu {\em mii\_bus} a~byl odstraněn a~je nahrazena  strukturou {\em platform\_device}, aby se~vyhnulo většině změn v~subsystému DSA dle připomýnky v~mailing listu \ref[ML].
%Starší verze této struktury neobsahovala položku platform\_device. Ta byla doplněna až na~základě připomínky, vyplývající z~komunikace s~vývojáři Linuxového jádra \ref[ML].
%A~proto byl ovladač zařízení Asix AX88772b doplněn o~funkci {\em dsa\_create\_pdev}, která je~schopna naplnit strukturu {\em platform\_device}.
%Tato struktura byla vytvořena po kontrole zařízení ve~funkci {\em dsa\_bind}.

Po naplnění základních struktur ovladač Asix AX88772b nainicializuje subsystém DSA zavoláním funkce {\em dsa\_probe\_netdevice()}.
Následná změna DSA subsystému je~popsaná v~\ref[dsadri].

\label[dsadri]

\secc Úprava subsystému DSA

Subsystém DSA byl rozšířen o~veřejnou funkci {\em dsa\_probe\_netdevice()}, která vytváří instanci {\em dsa\_switch\_tree} reprezentující Ethernetový přepínač.
Každý port přepínače je reprezentován vlastním virtuálním Ethernetovým rozhraním net\_device popsaným v sekci \ref[NETDEV].
Tato Ethernetová rozhraní jsou závislá na rodičovském síťovém rozhraní ovladače Asix AX88772b, které je jim nadřazené.

%Kvůli problému v~komunikaci bylo potřeba odloučit datovou strukturu DSA od platform\_driveru, což následně způsobilo rozšíření dsa\_switch\_driver \ref[mvdri].

V části ovladače, která má za úkol uvolňovat paměť, bylo potřeba provést několik změn, jelikož v~původním provedení se~nepředpokládalo, že by se~tento ovladač někdy uvolňoval.
To plyne z~debaty na~\cite[ML].
Funkce na~uvolňování ovladače nebyla v~původní verzi dokončena, a~proto byla upravena část její uvolňovací rutiny {\em dsa\_destroy()}, která ve verzi 3.19 Linuxového jádra podporuje uvolnění všech portů interpretovaných strukturou net\_device a~interních struktur DSA ovladače, jako je~struktura {\em dsa\_switch a~dsa\_switch\_tree}.


\label[mvdri]

\secc Vytvoření ovladače zařízení Marvell 88E6065

Pro ovládání zařízení Marvell 88E6065 bylo zapotřebí vytvořit ovladač, protože není naimplementován ve verzi 3.19 v~Linuxovém jádře.

Tento ovladač je~instancí struktury dsa\_switch\_driver, jak je~vidět na~obrázku \ref[umlDSA].
Struktura dsa\_switch\_driver obsahuje metody, které zajišťují inicializování, uvolnění a~nastavení přepínače jako celku i jeho jednotlivých portů, též obsahuje metody pro~zápis na~médium.


\sec Spojení jednotlivých ovladačů


Všechny ovladače jsou implementovány tak, aby vykonávaly svou část.

Při připojení USB zařízení a~vyčtení identifikátoru ze zařízení se zavede ovladač AX88772b, který aktivuje rozhraní PHY.
Po zápisu do~souboru {\em usb\_dsa\_bind} v~adresáři příslušného USB zařízení se na čipu Asix AX88772b aktivuje rozhraní RMII a~nainicializuje se Ethernetový přepínač.
DSA subsystém tak vytvoří pro káždý port přepínače rozhraní a~připojí příslušný ovladač pro~přepínací obvod.
V případě dané desky se jedná o ovladač pro Ethernetový přepínač Marvell 88E6065.

Po úspěšném spojení jednotlivých ovladačů je možné konfigurovat ovladač pomocí uživatelského nástroje ethtool.

\sec Odezva komunity

Změny v kódu Linuxového jádra, popsané v předchozích sekcích, byly posalány formou \uv{patchů} k okomentování komunitou vývojářů Linuxového jádra.
Odezva komunity byla velmi rychlá
\fnote{\url{http://lists.openwall.net/netdev/2015/04/21/20}},
odpovědi se~mi dostalo během pouhých pár hodin.
Vývojář Andrew Lunn se~vyjádřil k~mému nápadu a~navrhl několik optimalizací:
vyhnout se~změnám v~DSA subsystému a~vytvořit obalovací ovladač pro~ovladač kontroléru AX88772b.

Využil jsem radu vyhnout se změnám v subsystému DSA a needitoval jsem do velké míry alokující část subsystému DSA.
Avšak druhou navrhnutou optimalizaci, kterou bylo vytvoření obalujícího ovladače pro ovladač Asix AX88772b, jsem nepoužil, protože má změna v tomto ovladači nijak neovlivňuje jeho chování.

Můj příspěvek strhl debatu o~možnostech subsystému DSA v~Linuxovém jádře -- subsystém DSA prý není připraven pro~podporu připojování a~odpojování zařízení za~běhu systému.
Pravděpodobně však tato změna subsystému DSA nenastane ani v~příštích verzích Linuxového jádra.
Z diskuze však vyplynulo, že se~pravděpodobně celý subsystém DSA v~budoucnu přepíše.

\label[INIT]

\sec Inicializace zařízení

Tato část testuje inicializaci zařízení a následné zapnutí Ethernetových portů přepínače.
Nastavení připojeného konfigurovatelného přepínače bylo provedeno nástroji ifconfig a~ip.

Dalším krokem po připojení zařízení bylo nastavení rodičovského síťového rozhraní jako aktivní.
V našem případě se jednalo o zařízení {\em eth1}, které reprezentovalo zařízení Asix AX88772b.

\begtt
> ifconfig eth1 up
\endtt

Po aktivování rodičovského zařízení bylo nutné připojit tento uzel k~DSA subsystému.
To bylo provedeno zapsaním číslice 1 do~souboru {\em usb\_dsa\_bind}, který se~nachází ve~složce patřící k~příslušnému USB zařízení, v~našem případě je~tato cesta {\em /sys/devices/soc0/c5008000.usb/usb3/3-1/3-1.1/DSA\_BIND/dsa\_bind/usb\_dsa\_bind}.
Pak tento příkaz vypadá následovně.

\begtt
> echo 1 > /sys/devices/soc0/c5008000.usb/\
     usb3/3-1/3-1.1/DSA\_BIND/dsa\_bind/usb\_dsa\_bind
\endtt

Po tomto příkazu byl ovladač přepínače inicializován a~vytvořil virtuální rozhraní pro~každý ze svých portů.
Zapnutí tohoto portu by mohlo probíhat například následovně, kde název rozhraní portu je~{\em port1}.

\begtt
> ifconfig port1 up
\endtt

Tento příkaz aktivuje {\em port1}, který má nastavenou automatickou konfiguraci rychlosti a~tento port není umístěn v~žádné z~VLAN.

Po provedení těchto příkazů se povedlo úspěšně nastavit Ethernetový port přepínače.

\label[TEST]

\chap Testování

Tato kapitola se~zabývá testováním implementovaného řešení zejména na~propustnost a~stabilitu sítě.
Jelikož se~jedná o~systém s~podporou inicializace za~běhu, je~také důležité, aby se~v~řešení neobjevovaly žádné neuvolněné bloky paměti.

\sec Testování uvolňování paměti

Testování uvolňování paměti proběhlo několika způsoby.

Prvním způsobem bylo testování pomocí nástroje v~Linuxovém jádře, kterou je~Kernel Memory Leak Detektor
\fnote{Kernel Memory Leak Detektor je~nástroj v~Linuxovém jadře, který umožňuje nalezení špatného uvolnění paměti. Funguje podobně jako trasující garbage collector.}.
Tento nástroj sleduje alokované bloky a~ukladá si o~nich informace.
Pokud nalezne neuvolněný blok paměti, na který není žádná reference, vypíše chybovou hlášku, kterou můžeme vidět níže.

\begtt
unreferenced object 0xdaafbfc0 (size 64):
  comm "kworker/0:1", pid 29, jiffies 4294949812 (age 272.380s)
  hex dump (first 32 bytes):
    64 73 61 5f 62 69 6e 64 00 5a 5a 5a 5a 5a 5a 5a  dsa_bind.ZZZZZZZ
    5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
  backtrace:
    [<c00b6ee0>] kstrdup+0x2c/0x54
    [<c01359f4>] __kernfs_new_node+0x28/0xc4
    [<c013691c>] kernfs_new_node+0x1c/0x38
    [<c0136c40>] kernfs_create_dir_ns+0x18/0x60
    [<c0138a60>] sysfs_create_dir_ns+0x48/0x94
    [<c0215cb0>] kobject_add_internal+0x9c/0x2d0
    [<c0216034>] kobject_init_and_add+0x48/0x70
    [<c0369184>] ax88772_bind+0x174/0x220
    [<c03741b0>] usbnet_probe+0x208/0x6b4
    [<c038a9ac>] usb_probe_interface+0x164/0x1f4
    [<c02f54c8>] driver_probe_device+0x10c/0x22c
    [<c02f3c64>] bus_for_each_drv+0x44/0x8c
    [<c02f5384>] device_attach+0x70/0x88
    [<c02f4adc>] bus_probe_device+0x84/0xa8
    [<c02f3034>] device_add+0x2ec/0x4e0
    [<c0388818>] usb_set_configuration+0x530/0x75c
\endtt

Jak lze vidět z~tohoto výpisu, nástroj Kernel Memory Leak Detektor drží informace ke každé alokované instanci objektu a~ukladá o~ní informace, jako je~její velikost, stáří a~místo v kódu a stav zásobníku, kde byla paměť alokována.
Z těchto informací můžeme vyhledat, jaká funkce alokovala pamět, a~na základě toho opravit kód.

Chyba zmíněná výše nastala v~mém kódu, kdy jsem zapomněl odregistrovat instanci typu kobj v subsystému sysfs.

Po opravení této chyby, další neočekavané neuvolnění paměti tento nástroj neobjevil.

Dalším způsobem bylo testování skriptem, který opakovaně registruje a~odregistrovává ovladač.
Ten objevil chybu v~přístupu ke sdílenému objektu net\_device, konkrétně v~DSA subsystému, který obsahuje funkci {\em poll}, která je~vyvolána časovačem.
Tato funkce periodicky vyčítá stav portu ze zařízení.

Několikrát nastalo, že během zpracovávání funkce {\em poll} byla data, s nimiž funkce {\em poll} pracovala, uvolněna.
To zapříčinilo zpanikaření jádra a~následný pád systému.

Po uzamčení sdílených dat tento problém již nenastal.

\sec Testování zařízení a~výkonu

Cílem tohoto testu je otestovat kvalitu automatického nastavení fyzických linek přepínače a maximální rychlost přenosu dat přes přepínač.

V první řadě bylo potřeba se~ujistit, že přepínač je~dobře nastaven.
To probíhalo kontrolou od nejnižších vrstev ISO/OSI, linkovou, až po nějvyšší, kterou je~aplikační.

Po připojení UTP kabelu mezi přepínač a~počítač bylo nutné zapnout port přepínače \ref[INIT].
Po nastavnení portu přepínače by zařízení mělo začít komunikovat s~počítačem, tj.~měla by proběhnout automatická konfigurace rychlosti.
Toto je~možné vidět níže z~výpisu nástroje ethtool.

\begtt
> ethtool eth0
Settings for eth0:
	Supported ports: [ TP MII ]
	Supported pause frame use: No
	Supports auto-negotiation: Yes
	Advertised pause frame use: Symmetric Receive-only
	Advertised auto-negotiation: Yes
	Link partner advertised link modes:  10baseT/Half 10baseT/Full
	                                     100baseT/Half 100baseT/Full
	Link partner advertised pause frame use: No
	Link partner advertised auto-negotiation: Yes
	Speed: 100Mb/s
	Duplex: Full
	Port: MII
	PHYAD: 0
	Transceiver: internal
	Auto-negotiation: on
	Link detected: yes
\endtt

Zde je~vidět, že je~připojena fyzická linka a~přepínač podporuje automatickou konfiguraci rychlosti, konktrétně 10~Mb/s a~100~Mb/s s obousměrným či jednosměrným přenosem dat.

\medskip
\clabel[PCcon]{Síť pro~testování konfigurovatelného přepínače.}
\picw=10cm \cinspic images/cpcon.pdf
\caption/f Připojení konfigurovatelného přepínače pro~testování komunikace.
\medskip

Po připojení dalšího zařízení, aktivování dalšího z~portů a~nastavení IP adres vypadá zapojení tak, jak je~uvedeno na~obrázku \ref[PCcon].
Po tomto připojení mohlo být testováno, zdali přepínač správně přenáší data.
Mezi nejzákladnější testy přenosu dat patří ping, který je~jeden z~kontrolních zpráv ICMP protokolu.

\begtt
> ping 192.168.202.222
PING 192.168.202.222 (192.168.202.222) 56(84) bytes of data.
64 bytes from 192.168.202.222: icmp_seq=1 ttl=64 time=0.368 ms
...
--- 192.168.202.222 ping statistics ---
11 packets transmitted, 9 received, 18% packet loss, time 9997ms
rtt min/avg/max/mdev = 0.368/0.424/0.466/0.042 ms
\endtt

Jak je~vidět na~výpisu, zařízení PC2 úspěšně poslalo ICMP paket ping skrz přepínač, a~také na~tento dotaz dostalo odpověď formou ICMP paketu PONG.

Nyní bylo možno otestovat přenos dat na~reálných datech, která byla pro~tento účel načítána ze zařízení {\em /dev/zero}.
Pro spuštění testu rychlosti přenosu dat bylo nutno na~jednom z~těchto počítačů zapnout server, který bude naslouchat na~volném portu, v~našem případě na portu 4242.
Pro~tento úkol byl vybrán počítač PC1, který za~použití nástroje netcat spustil server, který poslouchá na~zvoleném portu.

\begtt
> nc -lk -z 4242 > /dev/null
\endtt

A na~druhém počítači PC2 bylo nutno zapnout přenos dat na~první počítač PC1 s~danou IP adresou a~daným portem tak, jak můžeme vidět na~výpisu níže:

\begtt
> dd if=/dev/zero bs=16000 count=625 | nc -v 192.168.202.222 4242
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
10000000 bytes (10 MB) copied, 0.877273 s, 11.4 MB/s
\endtt

Na tomto příkladě bylo odesláno 10~MB dat v~625 paketech, které byly přenesena rychlostí 11.4~MB/s.

\begtt
> dd if=/dev/zero bs=160000 count=625 | nc -v 192.168.202.222 2112
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
100000000 bytes (100 MB) copied, 8.49099 s, 11.8 MB/s
> dd if=/dev/zero bs=1600000 count=625 | nc -v 192.168.202.222 2112
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
1000000000 bytes (1.0 GB) copied, 85.9629 s, 11.6 MB/s
\endtt

Tyto testy také byly prováděny na~různých velikostech a~rychlost přenosu se~pohybovala v~rozmezí od 11.3~MB/s do 11.8~MB/s.
Toto rozmezí způsobuje délka a~počet hlaviček paketů.


Z testů lze tvrdit, že automatické nastavení rychlosti portů Ethernetového přepínače se nastaví správně na nejvýšší možnou rychlost a odesílaná data odpovídají rychlosti 100~Mb/s Ethernetu.

%\begtt
%[11.046] Unable to handle kernel paging request at Virtual Addr 6b6b6b77
%[11.053] pgd = c0004000
%[11.055] [6b6b6b77] *pgd=00000000
%[11.059] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
%[11.064] Modules linked in:
%[11.067] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.19.0 #298
%[11.075] Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
%[11.082] task: c08ba2a8 ti: c08ae000 task.ti: c08ae000
%[11.087] PC is at get_next_timer_interrupt+0xa0/0x294
%[11.092] LR is at get_next_timer_interrupt+0x60/0x294
%[11.098] pc : [<c006f474>]    lr : [<c006f434>]    psr: 90000093
%[11.098] sp : c08aff00  ip : 6b6b6b6b  fp : 00000000
%[11.109] r10: c0927540  r9 : ffff8f21  r8 : ffff8f20
%[11.114] r7 : 00000000  r6 : 3fff8f1f  r5 : ffff8f20  r4 : ffff8f17
%[11.121] r3 : 6b6b6b6b  r2 : 00000021  r1 : 00000023  r0 : c0927674
%[11.127] Flags: NzcV IRQs off FIQs on Mode SVC_32 ISA ARM Segment kernel
%[11.135] Control: 10c5387d  Table: 1ac0404a  DAC: 00000015
%[11.140] Process swapper/0 (pid: 0, stack limit = 0xc08ae238)
%[11.146] Stack: (0xc08aff00 to 0xc08b0000)
%[11.151] ff00: c08affa4 c060ecc0 0000001d c00625f0
%    fe44010c 0000000d c08aff40 c08b7154
%[11.159] ff20: 755c2278 00000002 c08ac640 60000000
%    00000185 dbbb4280 00000000 ffff8f20
%[11.216] [<c006f474>] (get_next_timer_interrupt)
%    from [<c007e34c>] (__tick_nohz_idle_enter+0x2d4/0x41c)
%[11.226] [<c007e34c>] (__tick_nohz_idle_enter)
%    from [<c007e4e0>] (tick_nohz_idle_enter+0x30/0x6c)
%[11.235] [<c007e4e0>] (tick_nohz_idle_enter)
%    from [<c00552c4>] (cpu_startup_entry+0x18/0x278)
%[11.244] [<c00552c4>] (cpu_startup_entry)
%    from [<c0868c0c>] (start_kernel+0x360/0x3cc)
%\endtt

%\sec Zhodnocení

\chap Závěr

V této práci byl vytvořen ovladač do~operačního systému Linux pro~konfigurovatelný Ethernetový přepínač dodaný firmou Retia a.s., který splňuje průmyslové teplotní rozsahy.

Na~modul Colibri T20, který má integrované hostitelské USB zařízení a~splňuje průmyslové teplotní rozsahy, byla naportována verze 3.19 jádra operačního systému Linux.
Dálé byl implementován ovladač pro~přepínač do~této verze operačního systému, který umožňuje inicializaci zařízení za~běhu a~umí reprezentovat každý port přepínače jako virtuální rozhraní viditelné v~uživatelském prostoru operačního systému Linux.



Tento ovladač je složen z~úpravy stávajícího ovladače pro~kontrolér Asix AX88772b, který byl rozšířen o~podporu ovládání rozhraní RMII a podporu připojení k subsystému DSA.
Další úpravou prošel subsystém DSA, který byl doplněn o~možnost připojení a uvolnění zařízení za~běhu.
Nakonec byl naimplementován ovladač pro~čip Ethernetového přepínače Marvell 88E6065, který ovládá funkčnost obvodu Ethernetového přepínače.

Implementace vytvořeného ovladače byla provedena na~verzi 3.19 Linuxového jádra a~změny v Linuxovém jádře byly zaslány k okomentování Linuxovou komunitou, kde bylo navrženo několik úprav a vylepšení.
Avšak moje změna nebyla začlenena do jádra.

Finální verze ovladače byla testována na správnost uvolňování paměti, korektnost konfigurace portů přepínače a rychlost přenosu dat.
Ve všech těchto parametrech dosáhl ovladač žádoucích výsledků.

%funguje, odezva, linuxova komunita, dosazene vysledky, vykon
%MII,RMII,GMII,RGMII,SGMII,QGMII,XAUI
%
%




> iperf -s
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
------------------------------------------------------------
[  4] local 192.168.202.11 port 5001 connected with 192.168.202.222 port 35991
[ ID] Interval       Transfer     Bandwidth
[  4]  0.0-10.0 sec   110 MBytes  91.8 Mbits/sec

> iperf -s -w 300k
------------------------------------------------------------
Server listening on TCP port 5001
TCP window size:  416 KByte (WARNING: requested  300 KByte)
------------------------------------------------------------
[  4] local 192.168.202.11 port 5001 connected with 192.168.202.222 port 46506
[ ID] Interval       Transfer     Bandwidth
[  4]  0.0-10.0 sec   109 MBytes  91.9 Mbits/sec

> iperf -s -u -i 1
------------------------------------------------------------
Server listening on UDP port 5001
Receiving 1470 byte datagrams
UDP buffer size:  208 KByte (default)
------------------------------------------------------------
[  4] local 192.168.202.11 port 5001 connected with 192.168.202.222 port 54405
[  4]  0.0- 1.0 sec  11.4 MBytes  95.3 Mbits/sec   0.219 ms   14/ 8120 (0.17%)
[  4]  1.0- 2.0 sec  11.4 MBytes  95.2 Mbits/sec   0.280 ms   19/ 8117 (0.23%)
[  4]  2.0- 3.0 sec  11.4 MBytes  95.3 Mbits/sec   0.154 ms   15/ 8117 (0.18%)
[  4]  3.0- 4.0 sec  11.4 MBytes  95.3 Mbits/sec   0.234 ms   16/ 8118 (0.2%)
[  4]  4.0- 5.0 sec  11.4 MBytes  95.3 Mbits/sec   0.388 ms   12/ 8116 (0.15%)
[  4]  5.0- 6.0 sec  11.4 MBytes  95.3 Mbits/sec   0.354 ms   18/ 8119 (0.22%)
[  4]  6.0- 7.0 sec  11.4 MBytes  95.3 Mbits/sec   0.160 ms   12/ 8119 (0.15%)
[  4]  7.0- 8.0 sec  11.3 MBytes  95.2 Mbits/sec   0.214 ms   21/ 8117 (0.26%)
[  4]  0.0- 8.5 sec  96.8 MBytes  95.3 Mbits/sec   0.415 ms  134/69193 (0.19%)
[  4]  0.0- 8.5 sec  1 datagrams received out-of-order
