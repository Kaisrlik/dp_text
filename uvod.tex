\chap Úvod

Cílem mé diplomové práce je vytvoření ovladače do operačního systému Linux pro přepínač založený na bázi Ethernetu, který by splňoval industriální teplotní rozsahy.
Tyto přepínače se v dnešní době téměř nevyrábějí a moduly, které by splňovaly tyto teplotní rozsahy a měly integrované MII rozhraní pro připojení fyzické vrstvy, jsou finančně velmi nákladné. 
Proto se tato práce zabývá možností připojení ethernetového přepínače pomocí USB sběrnice.

Vytvoření tohoto ovladače bylo zadáno firmou Retia a.s. se sídlem v Pardubicích. 
Tato firma se zabývá tvorbou elektronických vojenských systémů, záznamových zařízení a lokalizačních a bezpečnostních systémů.
Zadání bylo za účelem nahrazení staršího modelu konfigurovatelného přepínače, který splňuje industriální teplotní rozsahy, za výkonnější.
Firma poskytla pro tuto práci modul Colibri T20 a konfigurovatelný přepínač i s návrhem.
Přepínač je založen na přepínacím obvodu 88E6065 a je vyvinut firmou Marvell.
Deska konfigurovatelného přepínače je připojena USB-ethernetovým kontrolérem AX88772b, vyraběným firmou Asix, který podporuje připojení fyzické vrstvy za pomoci rozhraní RMII.

Pro vytvoření ovladače bylo potřeba provést portaci operačního systému Linux na modul Colibri T20, který má integrované hostitelské USB zařízení a splňuje industriální teplotní rozsahy.
Dálé bylo nutné implementovat ovladače do operačního systému Linux pro zařízení na bázi přepínacího obvodu s možností inicializace za běhu zařízení.
Implementace byla provedena na současné verzi Linuxového jádra se snahou zařadit ovladač do hlavní větve Linuxového jádra.

\medskip

Po úvodu následuje druhá kapitola \ref[pouztech], kde je popsána použitá technologie, jako je sběrnice USB \ref[USB] a  MII rozhraní \ref[MII].
Technologie jsou definovány, je vysvětleno, jak fungují, jaká mají omezení a jak vypadá jejich hardwarová implemementace.
Tyto informace se dozvíme i o rozšířeném rozhraní RMII \ref[RMIIsub].
Tato kapitole se také věnuje popisu mechanismu ovladačů a příslušných Linuxových subsystémů \ref[LINUXsub].
Konkrétně se jedná o části síťového subsystému, USB subsystému a subsystému přepínače.

V kapitole Použitý Hardware \ref[pouzhw] je popsán zvolený modul Colibri T20 a vyrobená deska konfigurovatelného ethernetového přepínače.
Zvláštní důraz je kladen na popis čipů použitých na této desce -- USB kontrolér Asix AX88772b a přepínací obvod Marvell 88E6065.

V následující kapitole s názvem Implementace \ref[impl] je popsán postup nahrátí nového Linuxového jádra a navazující postup při oživování desky.
Dále pak popisuje architektonický návrh ovladače pro operační systém Linux.
Následující část kapitoly rozebírá implementaci tohoto návrhu.

V kapitole s názvem Testování \ref[TEST] je popsáno, jak probíhá nastavení přepínacího obvodu.
Dále se zde popisují proběhlé testy ovladače přepínacího obvodu.
Na závěr kapitoly jsou výsledky těchto testů vyhodnoceny.

\label[pouztech]

\chap Použité technologie

V této kapitole je rozebírána použitá technologie.
V první části je popsána sběrnice USB \ref[USB].
V další významné části je popsáno rozhraní Media Independent Interface, které předpokládá znalost modelu ISO/OSI.
Ke konci této kapitoly je pojednáváno o tom, jak vypadají ovladače v operačním systému Linux a jak vypadá tvář linuxového subsystému Distributed Switch Architecture a k němu přilehlé subsystémy.

%LDD3 pekny popis zarizeni http://www.makelinux.net/ldd3/?u=chp-13-sect-4
%MAC podporuje 802.3 a 802.3u MAC funkce, jako je prijem a odeslani ramce, kontrolu CRC, duplex mode, forwarding, flow-control, detekce kolizi atd.

%\label[ISO]
%\sec Model ISO/OSI
%Model ISO/OSI je konceptuální model, který charakterizuje komunikačních sítích. Rozdělaná do vrstev.

\label[USB]

\sec Univerzální sériová sběrnice

Univerzální sériová sběrnice (USB) je technický standard vyvíjený od roku 1994 pro připojení periferií k počítači.
Tato sběrnice měla nahradit pomalé sběrnice (jako jsou sériová linka, paralelní port, PS2 a mnohé další) jednou sběrnicí \cite[LDD3].
V dnešní době USB umožňuje přenášet velké množství dat s rychlostí až 640 MB/s u USB zařízení verze 3.0.
Díky tomu se použití USB rozšířilo a nyní podporuje skoro každý druh zařízení, které umožňuje přenašet video, audio a dokonce i ethernetové rámce a pakety.
Podporovaná zařízení jsou rozdělena do tříd z důvodu sjednocení funkcionality a chování zařízení.
Nejznámějšími třídami jsou HID, Printer a Mass Storage, které jsou více popsány ve vývojářské dokumentaci \ref[USB].
Toto sjednocené chování má za důsledek využívání společných ovladačů, které tato zařízení mohou využívat.
Problém s některými druhy zařízení je takový, že je nejde do daných tříd zařadit, popřípadě mají rozšířené chování a potřebují speciální přístup.

\secc Rysy USB zařízení

USB je deterministická sběrnice (Master/Slave), která podporuje detekci připojeného zařízení za běhu (plug--and--play) a následnou automatickou konfiguraci (hotswap).
USB síť se skládá ze tří druhů zařízení \cite[USB]:
\begitems
*Hostitel -- je zařízení typu Master a je jako jediný v systému, řídí komunikaci a obvykle integruje rozbočovač označen jako kořenový.
Přiděluje zařízením unikátní adresu v síti.
*Rozbočovač -- distribuuje datové toky a identifikuje připojení a odpojení dalších zařízení.
*Zařízení -- pojmem zařízení je míňeno koncové zařízení s požadovanou funkcionalitou, které odpovídá na kontrolní zprávy.
\enditems

USB je asymetrická sběrnice s jedním zařízením typu Master, která spíše vypadá jako strom složený z linek bod-bod, přičemž USB huby vytvářejí jednotlivé uzly tohoto stromu a zařízení tvoří jejich listy.
Linky USB sběrnice jsou 4--vodičové skládající se z diferenciálního páru datových linek, napěťového a zemnícího vodiče, které jsou připojeny k zařízení a USB rozbočovačům.
USB umožňuje připojit až 127 zařízení v rámci jedné USB sítě o hloubce maximálně pěti rozbočovačů tak, jak můžeme vidět na obrázku \ref[USBhub].

\medskip
\clabel[USBhub]{USB tier.}
\picw=13cm \cinspic images/technet.microsoft.com.jpg
\caption/f Obrázek popisuje, jak lze USB zapojit \cite[MSTECH].
\medskip


Díky tomu, že sběrnice USB je typu Master/Slave, umožňuje jednoduchý mechanismus detekce a enumerace, nebo-li průběhu konfigurace (více informací níže \ref[USBkom]), za běhu systému.
Průběh enumerace je řízen a konfigurován automaticky hostitelem.


\label[USBkom]

\secc Komunikace

USB komunikace je založena na logických kanálech, tzv. rourách.
Každému výstupnímu kanálu by měl odpovídat právě jeden vstupní.
Koncový bod obsahuje rouru s definovaným směrem.

USB může mít maximalně 30 koncových bodů. Koncový bod je roura s definovaným směrem.
Tyto koncové body jsou inicializovány v průběhu enumarace USB zařízení, které probíhá po kontrolní rouře označené číslem 0, kterou mají všechna zařízení společnou.
Každý koncový bod obsahuje rouru s předem definovaným typem přenosu:

\begitems
*Řídící -- obousměrná roura sloužící ke konfiguraci zařízení. Každé zařízení disponuje tímto druhem roury. Má rezervovanou určitou přenosovou kapacitu.
*Izochronní -- jednosměrná roura sloužící ke stálému přenosu většího objemu dat. Má garantovanou latenci, přenos však není spolehlivý. Tento typ roury je vhodný pro audio a video.
*Přerušovací -- jednosměrná roura sloužící pro časté přenosy malého množství dat. Má garantovanou šířku pásma. A přenos dat je spolehlivý. V případě chyby se přenos opakuje.
*Blokový -- jednosměrná roura sloužící k přenosu velkého množství dat. Nemá rezervovanou žádnou přenosovou kapacitu ani dobu odezvy. Komunikace po této rouře je spolehlivá a v případě chyby se přenos opakuje.
\enditems

Enumerace je posloupnost standardizovaných příkazů, kterou započal hostitel.
V průběhu enumerace se předávají deskriptory, které obsahují důležité informace o zařízení.
Hierarchii deskriptorů lze vidět na obrázku \ref[USBhier].

\medskip
\clabel[USBhier]{Hierarchije USB deskriptorů.}
\picw=13cm \cinspic images/IMG019.pdf
\caption/f Obrázek popisuje, jak lze USB hierarchii deskriptorů interpretovat \cite[LUSB].
\medskip


\begitems
*Dekriptor zařízení -- obsahuje informace jako je ID výrobce a produktu.
Též obsahuje informace o třídě a maximální délce paketů, které může roura 0 přijmout.
*Konfigurační deskriptor -- oznamuje, jak má být zařízení napájeno, jaký má zařízení maximální odběr proudu a počet rozhraní.
Těchto dekriptorů může být více.
*Deskriptor rozhraní -- tento deskriptor informuje o funkcionalitě celku, jako je třída koncových zařízení a počet koncových bodů.
*Deskriptor koncového bodu -- používá se k přesnému popisu koncového bodu.
*Textový deskriptor -- tento deskriptor přenáší pouze čitelné informace o zařízeních kódované v Unicodu.
\enditems

Na základě informací v deskriptorech se operační systém rozhoduje, který druh ovladače přiřadí danému druhu zařízení.


\medskip \medskip \medskip \medskip

\label[MII]

\sec Media Independent Interface

Media Independent Interface (MII) je typ rozhraní, které umožňuje připojení nezávislé na procesoru a fyzickém médiu.
Tento typ rozhraní je specifikován standardem IEEE 802.3, který je popsán v kapitole 22 \cite[IEEE8023].
MII propojuje dvě vrstvy modelu ISO/OSI, a to vrstvu spojovou, konkrétně její část Media Access Constroll (MAC),
\fnote{MAC je popsána standardem IEEE 802.2001. Stará se o přijímání a odesílání rámců (přístup k médiu), ochranu proti chybám.}
s vrstvou fyzickou (PHY)
\fnote{PHY převádí bitový stream na signál a definuje jeho doručení.}.
MII rozhraní podporuje dva datové toky - 10~Mb/s a 100~Mb/s.
Na obou datových tocích je funkcionalita MII identická, liší se pouze v nominální frekvenci hodin.
Vyšší rychlosti přenosu je možno dosáhnout změnou rozhraní na Gigabite Media Independent Interface, které podporuje rychlost až 1~Gb/s.

\medskip
\clabel[MIItoISO]{Spojitost mezi MII a ISO/OSI}
\picw=16cm \cinspic images/802_iso.pdf
\caption/f Obrázek popisuje spojitost mezi rozhraním MII, modelem ISO/OSI a modelem IEEE 802.3 CSMA/CD LAN \cite[IEEE8023].
\medskip

Na obrázku \ref[MIItoISO] je vidět připojení MII na Reconsiliation Sublayer (RS) a Physical Coding Sublayer (PCS) nebo Physical Layer Signaling (PLS). %rozepsat zkratky
RS je podvrstva, která mapuje signály z MII na MAC/PLS obsluhu.
PLS a PCS jsou vrstvy, které se starají o kódování a dekódování signálů.
Konkrétní mapování MII signálů znázorňuje obrázek \ref[RStoMII].

\medskip
\clabel[RStoMII]{Mapování signálů RS na MII}
\picw=15cm \cinspic images/802_rs.pdf
\caption/f Obrázek popisuje, jak RS mapuje signály mezi MII a PLS. Také lze vidět připojení STA \cite[IEEE8023].
\medskip

Jak můžeme vidět na obrázku \ref[RStoMII], fyzické rozhraní MII se skládá ze dvou druhů sběrnic, a to datové \ref[MIIdat] a menežovací (STA) \ref[MDIOs].
STA může být připojeno až k 32 fyzickým jednotkám. které obsluhuje.

\label[MIIdat]

\secc Datová část MII rozhraní

Datová část MII disponuje několika druhy signálů, které lze vidět na pravé straně obrázku \ref[RStoMII].
Tyto signály jsou připojeny k přemapovací vrstvě RS.
Piny vysílající datové signály jsou: %TODO mozna lepsi popisek

\begitems
*TX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech TX\_EN, TXD a TX\_ER.
Zdrojem signálu TX\_CLK je vrstva PHY.
Frekvence tohoto signálu by měla být 20\% z nominální hodnoty přenosu dat, tedy $\pm 100ppm $.
*RX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech RX\_DV, RXD a RX\_ER.
Zdrojem signálu RX\_CLK je podvrstva RS. %XXX kouknout na manuál
RX\_CLK může odvodit referenční hodnotu frekvence z přijímaných dat nebo z nominální hodnoty jako u signálu pinu TX\_CLK.
*TX\_EN -- pin vysílající signál, který indikuje, že je podvrstva RS připravena odesílat data.
*TDX -- čtveřice datových pinů vysílající signál (TDX[3:0]) ovládaná podvrstvou RS, která přenáší data synchronně na základě signálu z pinu TX\_CLK.
TDX[0]  přenáší nejméně významný bit.
Pokud je TX\_EN fyzicky odpojen, TDX nemá žádný efekt na činnost vrstvy PHY.
*TX\_ER -- pin vysílající signál řízený podvrstvou RS, který indikuje. že vrstva PHY začala vysílat jeden či více symbolů, které nejsou součástí dat, nebo že předčasně došlo k přerušení rámce.
Signál na tomto  pinu je synchronní s hodinovým signálem z pinu TX\_CLK.
*RX\_DV -- pin vysílající signál, který značí, že přijatá data jsou validní. Tento signál je řízen vrstvou PHY a je synchronní se signálem z pinu RX\_CLK.
*RXD -- čtveřice datových pinů vysílající signál (RDX[3:0]) ovládaná vrstvou PHY. Tato čtveřice pinů slouží k přenosu dat z vrstvy PHY do podvrstvy RS.
RXD[0] přenáší nejméně významný bit.
*RX\_ER -- pin vysílající signál řízený vrstvou PHY, který indikuje, že nastala chyba detekovaná v průběhu přijímání rámce.
Pokud je pin RX\_DV odpojen, pin RX\_ER nemá žadný vliv na činnost podvrstvy RS.
*CRS -- pin vysílající signál indikující, zda je příjemce nebo odesílatel zaneprázdněn, nebo je ve stavu idle.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování. %XXX asi smazat
*COL -- pin vysílající signál, který je vyvolán vrstvou PHY, indikující kolize, které nastaly na médiu.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování.
\enditems
%Reprezentuje pokud josu data na odeslani nebo prijeti.

\medskip
\clabel[transiotionMII]{Komunikace po MII bez kolize.}
\picw=15cm \cinspic images/802_miicom.pdf
\caption/f Obrázek znázorňuje, jak vypadá bezchybná komunikace po MII rozhraní \cite[IEEE8023].
\medskip

Na obrázku \ref[transiotionMII] lze vidět, jak vypadá komunikace po MII rozhraní.
Pin TX\_CLK přenáší referenční hodinový signál, který se pravidelně mění.
Při odesílání dat se nahodí signál z pinu TX\_EN, který začne odesílat preambuli.
Přenos těchto dat je popsán níže.
S přijímaním signálu začne být příjemce zaneprázdněn, a proto nahodí signál z pinu CRS.
Celá komunikace probíhá pouze jedním směrem a neobsahuje žádnou chybu, jak je možno vidět ze signálu na pinu COL.

Rámec dat, který je přenášen po MII rozhraní, je doplněn o hlavičky a patičky popsáné formátem:

\begtt
<vstupní rámec><preambule><sdf><data><edf>
\endtt

Kde jednotlivé položky mají následující význam:

\begitems
*vstupní rámec -- je perioda mezi rámci, při které nesmí dojít k žádné činnosti na rozhraní MII.
Délka této periody není přesně specifikována.
*preambule -- je definovaná posloupnost dat, která se skládá ze 7 oktetů (bytů) a je přenášena ve formě pravidelného střídání jedniček a nul.
*sdf -- oktet, který oznamuje začátek rámce.
*data -- značí přenesená data.
*efd -- konec rámce, který provede deaktivaci signálu na pinu TX\_EN.
\enditems

Rámce jsou přenášeny tak, že oktet je rozdělen na dvě poloviny tzv. nibbles.
Tyto poloviny jsou odeslány po datových linkách TXD nebo RXD.
Příklad odeslání oktetu po pinech TDX je znázorněn na obrázku níže \ref[NIBBLE].

\medskip
\clabel[NIBBLE]{Rozdělení oktetu po datových pinech}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_nibble.pdf
\caption/f Obrázek popisuje, jak je rozdělen byte, který je následně odeslán po pinech TDX \cite[IEEE8023].
\medskip


\label[MDIOs]

\secc Menežovací rozhraní a příslušný registrový prostor

Menežovací část sběrnice, která se značí STA, se používá k nastavování a čtení hodnot mezi vrstvami MAC a PHY.
Toto rozhraní je dvoulinkové sériové a obsahuje dva datové vodiče:
\begitems
*MDC -- pin vysílající signál určující časovou základnu pro signál vysílaný pinem MDIO.
Signál z pinu MDC je aperiodický, nemá žádnou minimální ani maximální frekvenci, měl by se však pohybovat v rozmezí od 160~ns do 400~ns.
*MDIO -- pin vysílající signál. Tento pin je vstupně výstupní a jsou po něm posílány signály oběma směry.
Je tvořen třístavovým obvodem mezi vrstvami PHY a STA.
Pin se používá k přenosu kontrolních zpráv mezi zařizeními.
Přenos je řízen z vrstvy PHY.
Signál z pinu MDIO je synchronizovaný se signálem z pinu MDC.
\enditems

Formát menežovacích rámců je popsán v tabulce \ref[MDIOframe].
Data z této tabulky jsou odesílána po pinu MDIO ve směru z levé strany tabulky do pravé.

\midinsert \clabel[MDIOframe]{Formát menežovacích rámců.}
\ctable{lllllllll}{
 \hfil            & PRE & ST & OP & PHYAD & REGAD & TA & DATA & IDLE \crl \tskip4pt
          čtení   & 1...1 & 01 & 10 & AAAAA & RRRRR & Z0 & D...D & Z \cr
          zápis   & 1...1 & 01 & 01 & AAAAA & RRRRR & 10 & D...D & Z \cr
}
\caption/t Tabulka popisující formát menežovacích zpráv \cite[IEEE8023] (Tabulka 22-12).
\endinsert

V tabulce \ref[MDIOframe] lze vidět hodnotu preambule (PRE), což je posloupnost 32 bitů skládajících se z hodnot logických jedniček.
Preambule slouží k synchronizaci signálu z pinu MDC.
Začátek rámce je označený ST a má hodnotu 01.
Poté jsou odesílána data popisující operační kód (OP), která určují druh operace: čtení nebo zápis.
PHYAD je zkratka pro fyzickou adresu zařízení o délce 5 bitů.
Tím dokážeme naadresovat až 32 zařízení.
První bit adresy je nejvíce významný bit.
Další položkou je adresa registru (REGAD) číslovaná podle níže uvedených registrů \ref[miireg].
Dalším blokem je TA.
Při operaci čtení hodnota TA obsahuje stav vysoké impedance (Z) sloužící k prohození příjemce za odesílatele, jak lze vidět na obrázku \ref[mdioread].
Prohození odesílatelů probíhá z důvodu požadavku odpovědi na operaci čtení.
Odpovědí se myslí vyžádaná hodnota z registru.
Při operaci zápis tato změna není potřeba a stav vysoké impedance je nahrazen logickou jedničkou.
Odesílaná data mají 16 bitovou hodnotu, tedy stejnou jako je velikost registrů.

\medskip
\clabel[mdioread]{Čtení registru po STA.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_miimdio.pdf
\caption/f Obrázek znázorňuje čtení z registru při komunikaci po sériové lince STA \cite[IEEE8023].
\medskip

Operacemi čtení a zápis může vrstva MAC přistupovat k registrovému prostoru na vrstvě PHY, který tak může měnit.
Část tohoto registrového prostoru je definována standardem 802.3.
Registrový prostor obsahuje dva základní sety registrů -- kontrolní a stavový.
Všechny vrstvy PHY, které podporují rozhraní MII, by měly používat právě tuto sadu registrů \ref[miireg].


\medskip
\clabel[miireg]{Registry STA rozhraní.}
\picw=15cm \cinspic images/802_miireg.pdf
\caption/f Obrázek popisující registry STA rozhraní. Obrázek je převzat z~\cite[IEEE8023].
\medskip


Tyto registry specifikují základní vlastnosti vrstvy PHY pro MII rozhraní o rychlostech 100~Mb/s a 1~Gb/s.
Registry 2 -- 14 jsou částí rozšířeného registrového prostoru \cite[IEEE8023] (22.2.4).
Bližší popis stavového a kontrolního registru je uveden v příloze \ref[MIIcntr] a \ref[MIIstat].


% Ne do DP
%\sec GMII

%The Gigabit Media Independent Interface (GMII) is similar to the MII. The GMII uses the MII management interface and register set specified in 22.2.4. These common elements of operation allow Station Management to determine PHY capabilities for any supported speed of operation and configure the station based on those capabilities. In a station supporting both MII and GMII operation, configuration of the station would include enabling either the MII or GMII operation as appropriate for the data rate of the selected PHY. Most of the MII and GMII signals use the same names, but the width of the RXD and TXD data bundles and the semantics of the associated control signals differ between MII and GMII operation. The GMII transmit path clocking also differs significantly from MII clocking. MII operation of these signals and clocks is specified within Clause 22 and GMII operation is specified within Clause 35.
%GMII obsahuje 3ti zakladni registr Extended status reg(15)

\label[RMIIsub]

\secc Reduce Media Independent Interface

Reduce Media Independent Interface (RMII) je obdoba rozhraní MII, která má ale snížený počet pinů z 16 na 8 \cite[RMII].
RMII přidává pouze Reconciliation Sublayer (RS), a to buď jako novou, která je připojena za stávající RS, nebo jako náhradu aktuální podvrstvu RS v rozhraní MII \cite[RMIIcon].

Připojenou podvrstvy RS za stávající rozhraní lze vidět na obrázku \ref[RMIIRS].

\medskip
\clabel[RMIIRS]{Rozšíření MII o další RS.}
\picw=15cm \cinspic images/rmiirs.pdf
\caption/f Obrázek znázorňující rozšíření rozhraní MII o další podvrstvu RS.  Obrázek je převzat z~\cite[RMII].
\medskip

RMII používá stejné menežovací rozhraní jako MII definované standardem IEEE 802.3u \cite[IEEE8023], který je popsán v sekci \ref[MDIOs].

Hlavními rozdíly RMII rozhraní oproti MII jsou datové piny TXD a RXD. které jsou v RMII rozhraní pouze 2 bity široké.
Dále signály z pinů COL a CRS jsou zde sjednoceny do jednoho signálu na pinu CRS\_DV.
Dalším rozdílem je detekce kolizí, která je na vrstvě MAC provedena jako logický součin signálů TX\_EN a CRS\_DV.
Zdrojem hodinového signálu je vrstva MAC nebo je generován externími hodinami.


% TODO
%\sec linux

%\sec info kernel

%\sec loading proces

%\sec disribuce

%\secc openwrt

\medskip \medskip \medskip \medskip

\label[LINUXsub]

\sec Subsystémy operačního systému Linux

Tato kapitola obsahuje informace o tom, co to je ovladač, a dále popisuje základní stavební prvky naimplementováné v operačním systému Linux: device, net\_device, usb subsystém, usbnet, mii\_bus, DSA a sysfs.

\secc Ovladač

Ovladač je část programu (algoritmu), která spravuje nebo kontroluje určité zařízení připojené k počítači.
Ovladače vytvářejí softwarové rozhraní pro hardwarové zařízení, které umožňují operačnímu systému ovládat tento hardware, aniž by uživatel věděl, jak přesně funguje \cite[LDD3].

Linuxové jádro je monolitivký operační systém a proto ovladače zařízení jsou nahrány ve stejném prostoru jako samotné jádro.
Avšak umožňuje zavádět tyto ovladače za běhu systému nebo při jeho kompilaci.

\secc device

Každé zařízení naimplementované na nejnižší úrovni je v operačním systému Linux reprezentováno instancí struktury {\em device}.
Struktura device obsahuje informace o tom, co zařízení potřebuje, aby správně fungovalo v systému.
Mnoho subsystémů uchovává informace o struktuře device a tyto informace využívá k dalším procesům.
V dnešní době je velmi obtížné nalézt zařízení, které by bylo reprezentováno pouze strukturou {\em device}.
Místo toho některé instance ve struktuře {\em device}, jako je kobj, obecně implementují zařízení, která jsou nadřazená struktuře {\em device} \cite[DEV].
\fnote{Popis datové struktury {\em device} lze nalézt na \url{http://lxr.free-electrons.com/source/include/linux/device.h\#L730}}.

\label[NETDEV]

\secc net device

Struktura {\em net\_device } popisuje síťové rozhraní jak fyzické tak virtuální (jako jsou VLAN)\cite[ULNI].
Síťové rozhraní může přijímat a vysílat velké množství dat, a proto je implementace podobná diskovým zařízením \cite[LDD3].
Síťová zařízení přijímají data asynchronně a ukládájí je do vyrovnávací paměti.

V linuxovém jádře je síťový subsystém naimplementován tak, že je na protokolu nezávislý.


Jednotlivé složky struktury {\em net\_device } mohou být klasifikovány do několika kategorií \cite[ULNI]:
\begitems
*Konfigurace -- některá konfigurace je dána Linuxovým jádrem a nějaké jsou možné nastavit programy z uživatelského rozhraní, jako je ifconfig a ip.
*Statistiky -- statistiky jako počet odeslaných paketů a paketů přiajtých, popsané v struktuře, která se jmenuje priv.
*Stav zařízení
*Menežování přenosu -- nastavení kvality služeb (QoS).
*Tabulka virtuálních funkcí -- tyto ukazatele jsou implemntovány ovladači zařízeních. Obsahují funkce jako je nahození portů, shození portů, nastavení adres a mnohé další popsané v dokumentaci Linuxového jádra nebo \cite[ULNI].
\enditems


\label[USBst]

\secc USB subsystém

Linuxové jádro podporuje dva druhy USB ovladačů -- ovladače na hostovském systému a ovladače na zařízení \cite[LDD3].
USB ovladač na hostovském systému pracuje na systému, ke kterému je USB zařizení připojeno.
Ovladač na zařízení, neboli \"USB gadget drivers\", je připojen k hostovskému systému a chová se jako hostovská stanice připojená přes USB. %TODO opravit vetu
Na obrázku níže můžeme vidět USB hierarchii, kde USB může existovat v několika různých subsystémech (net, block, char ...). %chybí obrázek TODO XXX
USB jádro implementuje rozhraní pro USB ovladače, které chtějí kontrolovat hardware a přistupovat k němu.

Koncové body USB jsou popsány v jádře Linuxu strukturou {\em usb\_host\_endpoint}.
Tato struktura obsahuje informace o reálném koncovém bodu ve struktuře {\em usb\_endpoint\_descriptor}.
Struktura {\em usb\_endpoint\_descriptor} popisuje data pomocí přijatých deskriptorů.

\medskip
\clabel[USBMAP]{Hierarchie USB.}
\picw=15cm \cinspic images/usbendpmap.pdf
\caption/f Na obrázku lze vyčíst hierarchii USB prvků. Obrázek převzat z \cite[LDD3]. 
%TODO popisek
\medskip


USB rozhraní je složeno z několika koncových bodů, které tvoří jedno logické připojení jako je napřiklad myš, klávesnice, video atd.
Některá USB zařízení však mohou mít více rozhraní.
Například USB repoduktory mohou mít dvě rozhraní, jako je USB klávesnice pro tlačítka reproduktoru a USB audio pro jeho zvuk \cite[LDD3].%TODO presunout nahoru
Linuxové jádro používá pro každé rozhraní právě jeden hardwarový ovladač.
Toto rozhraní je popsáno strukturou {\em usb\_interface}.
Tato struktura je to, co USB jádro předává USB ovladačům.

Každé zařízení je vázáno konfigurací, které je předáváno v deskriptorech.
Linuxové jádro popisuje konfigurace ve struktuře {\em usb\_host\_config} a celé USB zařízení strukturou {\em usb\_device}.
Jedno USB zařízení však může mít konfigurací více.
Konfigurace se mohou v průběhu práce zařízení měnit.
Linuxové jádro ale nemůže obsluhovat více konfigurací v jeden čas.


Ovladače USB zařízení  obyčejně přepisují data z {\em usb\_interaface} do {\em usb\_device}.
Samotné struktury {\em usb\_device} a {\em usb\_interface} jsou zobrazeny v subsystému sysfs \ref[SYSFS] jako jednotlivé soubory.
Ukázková cesta ke struktuře {\em usb\_device} reprezentována pomocí sysfs \ref[SYSFS] může vypadat následovně:

\begtt  /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1  \endtt

K výše uvedené cestě k USB zařízení je na zvýrázněném řádku USB rozhraní reprezentováno strukturou {\em usb\_interface}.
Tato struktura je pojmenována podle formátu root\_hub-hub\_port:config.interface (pro hlubší stromy je schéma root\_hub-hub\_port-hub\_port:config.interface):

\begtt /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1/2-1:1.0 \endtt

Pro komunikaci se všemi USB zařízeními používá Linuxové jádro strukturu USB request block (urb).
Struktura urb definuje asynchronní typ komunikace, která se využívá k posílaní a příjmu dat pro specifický koncový bod USB a specifické USB zařízení.

\label[USBNET]

\secc usbnet

Usbnet je subsystém Linuxového jádra, který umožňuje ovládat USB--síťová zařízení jako je ethernet, DSL, IDSN atd. \ref[USBNET]
Usbnet je obecná USB--síťová nadstavba, která pracuje na různých rychlostech a nad různými protokoly.

Na obrázku níže lze vidět uml diagram důležitých struktur v ovladači AX88772b \ref[umlASIX].

\medskip
\clabel[umlASIX]{Diagram tříd ovladače AX88772b.}
\picw=15cm \cinspic images/driver_asix.pdf
\caption/f Na obrázku můžeme vidět popis vybraných datových struktur v subsystému usbnet.
\medskip

Na obrázku \ref[umlASIX] je znázorněn subsystém usbnet obsahující informace o:
\begitems
*net\_device -- zařízení reprezentující síťové rozhraní
*driver\_info -- rozhraní pro ovladač usbnet zařízení
*usb\_device -- struktura reprezentující zařízení USB
\enditems


\secc mii bus

Struktora {\em mii\_bus} reprezentuje MII rozhraní tabulkou virtuálních funkcí a umožňuje přístup k registrům popsaných v oddíle \ref[miireg].

\label[DSA]

\secc Distributed Switch Architecture

Distributed Switch Architecture (DSA) je subsystém pro menežování hardwarových přepínačů \cite[DSA].
%Obsahuje MII menežovací registry, příkazy pro nastavení přepínače a formát ethernetových hlaviček, který signalizuje na kterém portu byl paket přijat nebo ktery se hodlá odeslat 
Tento subsystém podporuje přepínače, které jsou připojeny způsobem zobrazeným na obrázku \ref[DSAcon].

\medskip
\clabel[DSAcon]{Připojení DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Tento subsystém reprezentující přepínače interpretuje každý port jako oddělené síťové rozhraní \ref[NETDEV].
Nastavování přepínače, jako je nastavení portů a menežování MII rozhraní, je provedeno na základě virtuální tabulky funkcí {\em ethtool\_ops}, kterou využívá například nástroj Ethtool \fnote{Ethtool je standardní utilita Linuxu pro ovládání a podporu ovladačů a zařízení \cite[EMBLINUX].}.

Subsystém DSA podporuje i propojení mezi přepínači tak, jak je možno vidět na obrázku \ref[DSAcon2].
Takto propojené přepínače lze ovládat skrz MII rozhraní.

\medskip
\clabel[DSAcon2]{Připojení více přepínačů DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon2.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Na obrázku \ref[umlDSA] je diagram tříd důležitých struktur v subsystému DSA, které jsou nezbytné pro funkčnost subsystému.

\medskip
\clabel[umlDSA]{Diagram tříd DSA subsystému.}
\picw=15cm \cinspic images/dsa_uml.pdf
\caption/f Na obrázku jsou popsány vybrané datové struktury.
\medskip

Na tomto obrázku jsou zvýrazněny struktury {\em mii\_bus}, {\em net\_device} a {\em dsa\_platform\_data}.
Tyto struktury DSA subsystém nevytváří, a proto je potřeba je předat subsystému způsobem, který je popsán v kapitole Implementace \ref[ARCH].

%XXX upravit aby to bylo více vypovídající
Subsystém DSA je reprezentován strukturou {\em dsa\_switch\_tree}, která obsahuje odkazy na struktury:
\begitems
*dsa\_platform\_data -- tato struktura obsahuje informace o kořeovém zařízení.
Také obsahuje strukturu {\em dsa\_chip\_data} popsanou níže.
*net\_device -- tato struktura odkazuje na hlavní síťové zařízení \ref[NETDEV], za učelem znalosti protokolu.
*dsa\_switch -- obsahuje data pro jednotlivé přepínače popsané níže.
\enditems

Struktura {\em dsa\_switch} nesoucí data o připojeném přepínači obsahuje následující data:
\begitems
*dsa\_switch\_tree -- je odkaz na rodičovskou strukturu.
*dsa\_chip\_data -- struktura obsahující informace o fyzickém přepínači -- kolik má portů a jaké jsou jejich názvy.
Navíc obsahuje informace o popisu hardwaru ve zkompilovaném device tree \fnote{Device tree je popis hardwarového zařízení ve speciálním formátu \cite[DT].}.
*device -- je odkaz na hostovské zařízení přepínače. %TODO neni na obrazku UML diagramu
*dsa\_switch\_driver -- struktura popisující ovladač přepínačů, obsahuje funkce na menežování připojeného přepínače, v jádře se tato struktura někdy označuje jako tabulka virtuálních funcí \cite[ULNI].
*mii\_bus -- je ovladač MII sběrnice.
*net\_device -- je odkaz na síťové zařízení \ref[NETDEV] reprezentující port zařízení.
\enditems




\label[SYSFS]

\secc System Filesystem

System FileSystem (Sysfs) je charakteristika Linuxového jádra od verze 2.6, která umožňuje jadernému kódu exportovat informace do uživatelského prostoru za použití paměti VFS\ref[SYSFS].
Hlavním účelem je reprezentovat objekty jádra, jejich atributy a jejich vztahy navzájem.
Většina atributů je reprezentována souborem, který je ve formátu ASCII a obsahuje pouze jednu hodnotu.
Sysfs poskytuje dvě složky:

\begitems
*kernel programming interface -- slouží k exportování a importování položek (viz níže) skrz sysfs do jádra
*user interface -- slouží k zobrazení a manipulaci s těmito položkami (viz níže), které mapuje zpět na objekty v jádře
\enditems

Mapování objektů a atributů můžeme vidět v \ref[SYSFSmap].

\midinsert \clabel[SYSFSmap]{Mapováni objektů a atributů v sysfs.}
\ctable{ll}{
 \hfil  Interní   & Externí  \crl \tskip4pt
        Jaderné objekty    & Složky  \cr
        Atributy objektů     & Soubory  \cr
        Vazby mezi objekty   & Symbolické odkazy  \cr
}
\caption/t  Tabulka popisující mapování objektů a atributů z jádra. Tabulka převzata z \cite[SYSFS].
\endinsert

Toto mapování lze vidět ve složce {\em /sys/}, která reprezentuje zařízení a data jádra.
Složka /sys/ může vypadat následovně:
\begtt
    /sys/
    |-- block
    |-- bus
    |-- class
    |-- devices
    |-- firmware
    |-- module
    ‘-- power
\endtt

Sysfs je reprezentováno v Linuxovém jádře jako struktura {\em kobj}, která obsahuje tři druhy obslužného volání -- na zápis, čtení a na uvolňení.

\label[pouzhw]


\chap Použitý hardware

Tato kapitola popisuje použitý modul na kterém byl provaděn vývoj ovladačů.
Také popisuje desku konfigurovatelného přepínače a čipy, které jsou na této desce použity.

\label[T20]

\sec Počítačový modul Colibri T20

Colibri T20, vyráběný firmou Toradex \cite[TODADEX], je počítačový modul postaven na základě NVIDIA Tegra 2 vestavěném systému na čipu \cite[SOC].
Tento modul dále obsahuje 256~MB DDR2 paměti a 512~MB NAND flash paměti.
Má velké množství komunikačních rozhraní jako je I2C, SPI, UART, MMC, USB, ethernet a PWM.
Také obsahuje výstup na video a audio.
Čip obsahuje periferie popsané na blokovém diagramu na obrázku \ref[SOC].

\medskip
\clabel[SOC]{Colibri T20 blokový diagram.}
\picw=15cm \cinspic images/soc.pdf
\caption/f Obrázek popisuje části integrované na modulu Colibri T20 \cite[SOC].
\medskip

Firma Toradex dodává k tomuto modulu podporu pro Linuxové jádro verze 3.1.10.

\sec Systém na čipu NVIDIA Tegra 2

Systém na čipu NVIDIA Tegra 2 od firmy ARM je založen na dvoujádrovém procesoru Cortex A9 se symetrickým procesorovým jádrem s frekvencí procesoru okolo 1~GHz \cite[TEGRA2].
Jelikož se jedná o systém na čipu, obsahuje tento čip mnoho bloků, jako je například Audio/Video rekordér, grafický procesor s podporou 2D rendrovaní a 3D pixelové a vektorové shadery.

Procesor Cortex A9 má 32-bitovou RISC
\fnote{Architektura RISC označuje procesory s redukovanou instrukční sadou \cite[RISC].}
architekturu vyvinutou společností ARM Holding věnující se vývoji procesorových jader.
Tento procesor podporuje out--of--order a spekulativní provádění instrukcí.
Má plnou podporu koherence pamětí pro symetrické procesory.
Procesor A9 dosahuje vysokého grafického i výpočetního výkonu, viz \cite[BENCH].
Procesor též obsahuje jednotku pro výpočty s plovoucí řádovou čárkou.

Popis jádra NVIDIA Tegra 2 lze vidět na obrázku níže \ref[TEGRA].

\medskip
\clabel[TEGRA]{Popis jádra NVIDIA Tegra 2.}
\picw=15cm \cinspic images/tegra2.pdf
\caption/f Obrázek popisuje architekturu procesoru NVIDIA Tegra 2 \cite[TEGRA].
\medskip

\label[ASIX]

\sec USB--Ethernet kontrolér Asix AX88772b


AX88772b je zákaznický integrovaný obvod vyráběný firmou Asix, který umožňuje plug--and--play Fast Ethernet internetové připojení pro zařízení využívající standardizované USB verze 1.1 a verze 2.0 popsané v \ref[USB].


Jako jediný z vyráběných modelů dosahuje v revizi AX88772bli teplotních rozsahů od $ -40^{\circ}C  až +85^{\circ}C $. Což odpovídá industriálním teplotním rozsahům.
AX88772b má modifikovatelnou vícefunkční sběrnici, která umožňuje připojit RMII \ref[RMIIsub] nebo Reverse-RMII způsobem MAC--to--MAC k mikrokontroléru s Ethernet MAC RMII rozhraním.
MAC rozhraní je plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u.

%TODO ASIX
\medskip
\clabel[ASIXcip]{Blokový diagram AX88772b.}
\picw=15cm \cinspic images/asix_conn.pdf
\caption/f Obrázek popisuje blokový diagram architektury čipu AX88772b od firmy Asix. Obrázek je převzat z \cite[ASIX].
\medskip
%jake umoznuje propojeni po rmii?

Jak je vidět na obrázku \ref[ASIXcip], čip AX88772b obsahuje ethernetovou vrstvu PHY, která však nemůže být aktivní současně s RMII rozhraním.
Dále obsahuje periferii pro připojení EEPROM paměti a nastavitelné piny nejčastěji používáné pro světelnou signaliaci.
Tento čip též obsahuje regulátor napětí z 3,3~V na 1,8~V.



\label[MARVELL]

\sec Ethernetový přepínač Marvell 88E6065

Marvell 88E6065 je 5~+~1 portový ethernetový přepínač integrovaný na čipu.
Obsahuje  pět portů na fyzické vrstvě 10~BASE-T/100~BASE-TX, z nichž dva porty mohou být využity pro optickou linku 100~BASE-FX,
Navíc obsahuje port, pro připojení MAC vrstvy za pomoci RMII nebo MII rozhraní.
Též jde připojit pouze přez menežovací rozhraní z MII.
Zařízení má vysokorychlostní neblokující čtyřúrovňový QoS
\fnote{QoS umožňuje síti, garantovat lepší kvalitu služeb. A umožňuje aplikacím požadovat a přijímat předvídatelné úrovně těchto služeb, aby zvýšili průtok sítě a její odezvu. \cite[CISCO].}.

Vrstva PHY tohoto zařízení podporuje plug--and--play s možností automatického určení směru, automatického určení polarity a automatického určení rychlosti.
Zařízení dále podporuje 64 z 4096 802.1Q WLAN s 3 úrovňovou ochranou.
Obsahuje dvě RMII/MII/SNI rozhraní, která mohou být připojena k menežovacímu rozhraní nebo ke kontroleru s integrovanou MAC.
MAC a PHY vrstvy jsou plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u a IEEE~802.3x.

Zařízení může být konfigurováno přes menežovací rozhraní nebo může načítat nastavení z EEPROM paměti.

Výjimečně se přepínač Marvell 88E6065 může využívat jako směrovač či výchozí brána.
%jake umoznuje porjojeni RMII
\medskip
\clabel[MARVELL6060]{Blokový diagram 88E6060.}
\picw=15cm \cinspic images/6060conn.pdf
\caption/f Obrázek popisuje blokové zapojení čipu 88E6060 od firmy Marvell, které je velmi podobné zapojení čipu 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

Jak lze videt na obrázku \ref[MARVELL6060], který popisuje Marvell 88E6060, který je velmi podobný zařízení Marvell 88E6065 obsahuje tento přepínač pouze 4~+~1 portů.
Avšak jako jako nevější model potřebuje externí hodinový krystal a zdroj napětí.

\label[SWITCH]

\sec Deska konfigurovatelného přepínače


Deska konfigurovatelného přepínače byla vyrobena firmou Retia a.s.
\fnote{Firma zabývající se elektronickými vojenskými systémy, záznamovými zařízeními a lokalizačními a bezpečnostními systémy. \url{www.retia.cz}}
na základě jejich návrhu a zapojení, ktará jsou popsaná v přílohách \ref[zapojeni1], \ref[zapojeni2].

Tato deska byla vyrobena za účelem nahrazení staršího modelu konfigurovatelného přepínače, který splňuje industriální teplotní rozsahy, za výkonnější.

Zjednodušené schéma této desky je znázorněno na obrázku \ref[deska].

\medskip
\clabel[deska]{Blokové schéma desky konfigurovatelného přepínače.}
\picw=15cm \cinspic images/diagdeska.pdf
\caption/f Obrázek popisuje blokové schéma zapojení desky konfigurovatelného přepínače.
\medskip

Konfigurovatelný přepínač umožňuje nastavení ethernetového přepínače za pomoci USB Ethernet kontroléru AX88772b od firmy Asix \ref[ASIX], ke kterému je připojena externí pamět EEPROM M93-C66 \fnote{Popsané na \url{http://www.st.com/web/catalog/mmc/FM76/CL1276/SC112/PF63995?referrer=70071840}}.
Tento kontrolér je připojen přes RMII rozhraní k čipu Marvell 88E6065 \ref[MARVELL] tak, jak lze vidět na obrázku níže \ref[MARVELL6065rmii].

\medskip
\clabel[MARVELL6065rmii]{Zapojení RMII k čipu Marvell 88E6065.}
\picw=10cm \cinspic images/rmii.pdf
\caption/f Obrázek popisuje připojení RMII rozhraní k zařízení Marvell 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

I k tomuto čipu je připojena externí pamět EEPROM.

Oba čipy Asix AX88772b a Marvell 88E6065 mají vlastní krystal s frekvencí 25~MHz.
Deska je navíc osazena regulátorem napětí a přepínači pro různá nastavení MII rozhraní (K3 a K2), resetování (K5) a externí vzbuzení (K4), jak je možno vidět v příloze \ref[zapojeni1].

\label[impl]

\chap Implementace

Tato kapitola rozebírá portaci aktuálního Linuxového jádra pro modul Colibri T20 \ref[T20], která byla zapotřebí pro další implementaci ovladačů.
Dále se zabývá způsobem oživení desky konfigurovatelného přepínače \ref[SWITCH] a následným popisem tvorby ovladače pro tento přepínač \ref[ARCH] a jeho implementace \ref[ZPRAC].

Vývoj byl prováděn na vývojovém kitu s modulem Colibri T20.
Pro vývoj ovladače bylo zvoleno jádro z upstreamové větve Linuxového jádra
\fnote{Linuxové jádro je možné stáhnout na \url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git}}.
Práce byla započata s verzí Linuxového jádra 3.17, a vzhledem k aktualizacím jádra byla přeportována na verzi 3.19.

\label[UPSTREAM]

\sec Portace upstreamového Linuxového jádra a zavaděče

Pro portaci upstreamového Linuxového jádra bylo vyžadováno několik nástrojů a programů pro překlad kódu, linkování a nahrání do paměti.

\secc U-Boot

Jako první krok bylo potřeba nainstalovat zavaděč, který by se postaral o zavedení Linuxového jádra na modul Colibri T20.
Pro tento úkol byl zvolen zavaděč U-Boot, který je využíván i výrobcem modulu Colibri T20, avšak byla zvolena jeho novejší verze
\fnote{U-Boot je možný stáhnout z repozitáře \url{git://git.denx.de/u-boot.git}}.

V následujícím kroku bylo nutné stáhnout a zkompilovat nejnovější zavaděč \cite[UPLINUXT20].
Jako konfigurační soubor byl zvolen {\em colibri\_t20\_iris\_config}, který popisuje modul Colibri T20 s vývojovou deskou Iris.

\begtt
> git clone git://git.denx.de/u-boot.git
> export CROSS_COMPILE=~/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
> export ARCH=arm
> make colibri_t20_iris_config
> make -j8
\endtt

Dále bylo potřeba stáhnout nástroje, které by sloužily k vytvoření cílového binárního souboru zavaděče U-Boot.

\begtt
> git clone https://github.com/NVIDIA/cbootimage-configs.git
> cbootimage -gbct -t20
		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.bct.cfg
 		colibri-t20_512_v12_nand.bct
> cp ../u-boot/u-boot-dtb-tegra.bin u-boot.bin
> cbootimage -t20
 		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.img.cfg
 		colibri-t20_512_v12_nand.img
\endtt

Poté byl zavaděč zaveden z diskového souboru  následujícím příkazem:

\begtt
> tegrarcm --bct colibri-t20_512_v12_nand.bct --loadaddr=0x00108000
 		--bootloader=../u-boot/u-boot-dtb-tegra.bin
\endtt

Po zavedení tohoto zavaděče bylo možné sledovat, jak se na konzoli modulu Colibri T20 zobrazil výpis tohoto zavaděče.
A za pomoci USB-ethernetového kontroléru, který byl integrovaný na modulu, byl nahrán obraz zavaděče do paměti RAM modulu.

\begtt
Tegra20 (Colibri) # usb start
(Re)start USB...
USB1: USB EHCI 1.00
scanning bus 1 for devices... 1 USB Device(s) found
USB2: USB EHCI 1.00
scanning bus 2 for devices... 2 USB Device(s) found
 scanning usb for storage devices... 0 Storage Device(s) found
 scanning usb for ethernet devices... 1 Ethernet Device(s) found
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot 0x02100000 colibri-t20_512_v12_nand.img
Waiting for Ethernet connection... done.
TFTP from server 192.168.80.3; our IP address is 192.168.80.90
Filename 'colibri-t20_512_v12_nand.img'.
Load address: 0x02100000
Loading: #################################
         3.6 MiB/s
done
Bytes transferred = 729088 (b2000 hex)
\endtt

Bylo nutné nahrát obraz zavaděče do paměti NAND a přepsat původní zavaděč současným.
Délka přeneseného obrazu byla 0xb2000, viz kód výše.
Tato hodnota byla potřeba k určení délky přepisovaného úseku NAND paměti.

\begtt
Tegra20 (Colibri) # nand erase.chip

NAND erase.chip: device 0 whole chip
Erasing at 0x3ffc0000 -- 100% complete.
OK
Tegra20 (Colibri) # nand write 0x02100000 0 0xb2000

NAND write: device 0 offset 0x0, size 0x95000
 577536 bytes written: OK
\endtt

Po resetu zařízení bylo možno vyčíst z konzole náběh nového upstramového zavaděče U-Boot, který ale v tento moment nebyl schopen nalézt žádné jádro operačního systému.
Jádro bylo přidáno v dalším kroku popsaném v sekci \ref[LINUXkernel].

\label[LINUXkernel]

\secc Linuxové jádro

Následujícím krokem  byla instalace aktuální verze jádra, která byla nutná k vývoji ovladačů a komunikaci s linuxovou komunitou.
Jelikož upstreamové jádro nepodporuje NAND paměť, načítání tohoto jádra bylo realizováno přes ethernetovou síť \cite[UPLINUXT20].

Pro instalaci Linuxového jádra bylo potřeba stáhnout a přeložit nejnovější verzi \cite[UPLINUXT20].
Pro nastavení jádra byla zvolena konfigurace {\em tegra\_defconfig}, která v jádře vybere moduly a ovladače pro jeho běh.

\begtt
> git clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
> export LOADADDR=0x408000
> export ARCH=arm
> export CROSS_COMPILE=/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
> make tegra_defconfig
> make -j8 uImage
\endtt

Po přeložení nejnovější verze bylo možno nahrát obraz jádra a přeloženého device tree
\fnote{Device Tree popisuje hardwarového zapojení modulu.}
do RAM paměti modulu za pomoci USB-ethernetového kontroléru v konzoli zavaděče U-Boot následujícími příkazy:

\begtt
Tegra20 (Colibri) # usb start
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot ${kernel_addr_r} uImage
Tegra20 (Colibri) # tftpboot ${fdt_addr_r} tegra20-iris-512.dtb
\endtt
%Load address: 0x1000000 kernel
%Load address: 0x2000000 dbt

Po nahrátí obrazů  byly nastaveny parametry pro Linuxové jádro
\fnote{\url{https://www.kernel.org/doc/Documentation/kernel-parameters.txt}},
tedy nastavení konzole, jejího portu a rychlosti, dále pak nastavení oddílu s distribucí a jejího typu filesystému.
Pokud v nastaveném oddílu bude nahrána distribuce se správným formátem, jádro tuto distribuci zavede.
Poté je možno spustit přeložené Linuxové jádro.

\begtt
Tegra20 (Colibri) # set bootargs console=ttyS0,115200n8 earlyprintk
		root=/dev/mmcblk0p1 rootfstype=ext2 rw rootdelay=1
Tegra20 (Colibri) # bootm ${kernel_addr_r} - ${fdt_addr_r}
\endtt



\sec Oživení desky

Pro oživení desky byl nejprve testován USB kontrolér Asix AX88772b \ref[oAX].
Po oživení komunikačního rozhraní tohoto kontroléru bylo dalším krokem ladění ethernetového přepínače Marvell 88E6065 \ref[oMV].
Nakonec bylo provedeno testování ethernetových portů celého systému.
V průběhu tohoto testování bylo objeveno několik chyb v návrhu desky. které byly na základě mých připomínek opraveny.

\label[oAX]

\secc Oživení USB--Ethernet kontroléru Asix AX88772b

%jak jsi oživoval Asix?
V průběhu oživování USB kontroléru byla objevena závada v jeho připojení na desce konfigurovatelného přepínače.
Tato závada se projevovala chybnou komunikací na USB sběrnici, která byla objevena při použití modulu Colibri T20.
Tato chybná komunikace je znázorněna na obrázku \ref[usbbuserr].
Je zde znatelné, že pakety, které dorazily k hostovskému zařízení, modul příjímal poškozené.

\medskip
\clabel[usbbuserr]{Chybná komunikace na USB sběrnici.}
\picw=15cm \cinspic images/wrong_com_wire.pdf
\caption/f Na obrázku je záznam chybné komunikace na USB sběrnici mezi PC a USB kontrolérem Asix AX88772b, která byla zaviněna nepřipojením blokovacího kondenzátoru.
\medskip

Po úpravě zapojení kontroléru začal USB kontrolér odpovídat na dotazy aktuálního ovladače v operačním systému Linux.
Také jej bylo možné objevit z uživatelského prostoru příkazem:
\begtt
lsusb
\endtt


\medskip
\clabel[ASIXRMII]{Připojení RMII k USB kontroléru Asix AX88772b.}
\picw=15cm \cinspic images/asix_rmii.pdf
\caption/f Obrázek zobrazuje připojení vrstvy PHY, popřípadě rozhraní RMII. Obrázek převzat z \cite[ASIX].
\medskip

Z obrázku \ref[ASIXRMII] lze vyčíst, že kontrolér AX88772b není schopen komunikovat po rozhraní PHY a RMII současně.
Zápisem do registru číslo 0 \cite[ASIXman] je aktivován právě jeden z daných dvou rozhraní a následně pomocí spojky K2 \ref[zapojeni1] je kontrolér nastaven do režimu MAC.

Posledním krokem k oživení USB kontroléru Asix AX88772b bylo nastavení vhodného chování tak, aby bylo zprovozněno rozhraní RMII, které je blíže popsané v \ref[ZPRAC].
%TODO popsat vhodné chování

\label[oMV]

\secc Oživení ethernetového přepínače Marvell 88E6065

K oživení a stabilnímu chování ethernetového přepínače Marvell 88E6065 bylo zapotřebí aktivovat RMII rozhraní a provést několik zásahů do zapojení čipu na desce.
Taktéž bylo zapotřebí aktivovat funkční komunikaci přes kontrolér Asix AX88772b \ref[oAX], který na základě USB příkazů je schopen posílat menežovací zprávy přes RMII rozhraní.
Navíc bylo potřeba vyřešit, v jakém módu bude tento ethernetový přepínáč připojen.
Pro připojení přepínače bylo zvoleno připojení MAC--to--MAC, ve kterém hodiny pro MDIO vysílá zařízení AX88772b a hodiny o frekvenci 50~MHz pro RMII rozhraní ethernetový přepínač Marvell 88E6065.
Zapojení je znázorněno na obrázku \ref[MARVELL6065rmii].

Protože i na tomto čipu byla nalezena chyba v komunikaci, byly doplněny chybějící blokovací kondenzátory.
Navíc byl objeven problém, že  tento čip se po každém zapnutí nastavil do odlišných nastavení.
Pro vyřešení tohoto problému byl k čipu doplněn kondenzátor, který zařízení opakovaně resetoval po dobu časové konstanty RC.

$$ T(s) = R (\Omega) * C(F)  $$

Deska tak měla během této doby možnost, aby se vstupní hodnoty na všech pinech ustálily ve správném stavu.

Pro zajištění správného a deterministického chování přepínače byly přidány pull-up a pull-down rezistory \ref[zapojeni2].
\begitems
*pull up rezistor -- pin SW\_MODE, ADDR4, P5\_MODE0, P5\_MODE1 a P5\_MODE3
*pull dwon rezistor -- pin P5\_MODE2
\enditems

\label[ARCH]

\sec Návrh ovladače

Ovladač byl navržen tak, aby propojoval ovladač pro Asix AX88772b se subsystémem DSA \ref[DSA].

Celý ovladač by měl podle návrhu fungovat tak, že při připojení USB zařízení se zavede ovladač pro zařízení AX88772b.
Toto zařízaní inicializuje tento ovladač do standardního stavu na základě funkce usb\_probe(), která podle ID produktu a výrobce vybere správný ovladač.
V tomto případě je to ovladač specifikovaný strukturou driver\_info a konkrétní instance se nazývá ax88772b\_info.
Tato instance je v současné době naimplementována v aktuální verzi Linuxové jádra.
Instance pomocí funkce asix88772\_bind nainicializuje ovladač tak, že ten aktivuje PHY rozhraní a vytvoří nové rozhraní pro ethernetovou komunikaci přes net\_device strukturu a ethtool\_ops a net\_device\_ops funkce.

Do návrhu byla doplněna funkce, která by měla vytvořit soubor v systému sysfs\ref[SYSFS].
Za pomoci obslužné rutiny vytvořeného souboru by měl být ovladač zařízení spojen s DSA subsystémem.
Tato rutina by měla předat DSA subsystému instance struktur net\_device, mii\_bus a informace o portech přepínače ve strutuře dsa\_platform\_data.
Všechny tyto instance nebo jejich odkazy by měla předat DSA subsystému struktura platform\_device.
Zmíněné struktury lze vidět na obrázku \ref[umlDSA].

Za pomoci těchto dat by se v DSA subsystému měl vytvořit ovladač pro přepínač.
Ovladač by si pak měl najít potřebné funkce pro konkrétní přepínač specifikovaný strukturou dsa\_switch\_driver a pro každý port by měl vytvořit nové vlastní síťové rozhraní.

Proces uvolňování ovladače z paměti by měl být řešen funkcí dsa\_remove. Ta by měla uvolnit celý subsystém DSA i na něm závislé instance, jako jsou síťová rozhraní.
Při odpojení desky od modulu by měl toto uvolnění poskytovat USB ovladač Asix AX88772b.

\label[ZPRAC]

\sec Zpracování

Sekce zpracování popisuje provedení jednotlivých částí ovladače podle návrhu \ref[ARCH].

Jelikož nebyl ovladač pro zařízení Asix AX88772b připraven na připojení RMII rozhraní, bylo zapotřebí nastavit toto rozhraní jako aktivní.
To však nemůže být aktivní současně s rozhraním ethernet PHY, které je taktéž integrováno na čipu, jak je zobrazeno na obrázku \ref[ASIXRMII].
Dále bylo potřeba upravit subsystém DSA tak, aby podporoval inicializace zařízení za běhu, konkrétně jeho odhlašování a uvolňování. 
Posledním krokem bylo vytvořit samotný ovladač pro zařízení ethernetového přepínače Marvell 88E6065, které řeší jeho funkčnost.

\label[asixdri]

\secc Změna ovladače zařízení Asix AX88772b

Ovladač zařízení Asix AX88772b je již podporován v Linuxovém jádře.
Jak již bylo zmíněno, zařízení nebylo schopno mít aktivováno více komunikačních rozhraní najednou, a proto bylo potřeba doplnit ovladač o aktivaci RMII rozhraní.
Byla zvolena možnost, že aktivace RMII rozhraní bude provedena přes zápis do souboru {\em dsa\_bind}, který je součástí filesystému sysfs a je umístěn ve složce USB zařízení.

Po zápisu do tohoto souboru byla vyvolána obslužná rutina {\em usb\_dsa\_store()}, která byla nainicializována instancí struktury kobj.
Tato rutina převzala informace o tom, kdo ji zavolal, a následně vyvolala funkci {\em dsa\_bind()}.
Příslušné registry pro aktivování RMII rozhraní byly nastaveny touto funkcí.

%TODO vyjmenovat příslušné registry
Další funkcí dané rutiny bylo testování, zda bylo k USB kontroléru připojeno zařízení Marvell 88E6065 dle standardizováného registrového prostoru \ref[miireg], konkrétně vyčtením z třetího registru, který obsahuje ID a revizi zařízení.

Tato rutina navíc vyplnila strukturu {\em asix\_common\_private}, která v současné verzi je kompatibilní s jádrem verze 3.19 a vypadá následovně:

\begtt
struct asix_common_private {
   struct asix_rx_fixup_info rx_fixup_info;
#ifdef CONFIG_NET_DSA
   struct kobject kobj;
   struct mii_bus *mdio;
   bool use_embphy;
   bool dsa_up;
   struct usbnet *dev;
   struct platform_device *pdev;
#endif
}
\endtt

%Ve verzi linuxového jádra 3.19 subsystém DSA byl upraven a nevyžaduje strukturu {\em mii\_bus} a byl odstraněn a je nahrazena  strukturou {\em platform\_device}, aby se vyhnulo většině změn v subsystému DSA dle připomýnky v mailing listu \ref[ML].
Starší verze této struktury neobsahovala položku platform\_device. Ta byla doplněna až na základě připomínky, vyplývající z komunikace s vývojáři Linuxového jádra \ref[ML].
A proto byl ovladač zařízení Asix AX88772b doplněn o funkci {\em dsa\_create\_pdev}, která je schopna naplnit strukturu {\em platform\_device}.
Tato struktura byla vytvořena po kontrole zařízení ve funkci {\em dsa\_bind}.

Po naplnění základních struktur ovladač Asix AX88772b zavolal funkci {\em dsa\_probe\_netdevice()}, která tvořila softwarové rozhraní přepínače.
Následná změna DSA subsystému je popsaná v \ref[dsadri].

\label[dsadri]

\secc Úprava subsystému DSA

Subsystém DSA byl rozšířen o veřejnou funkci {\em dsa\_probe\_netdevice()}, která vytváří softwarové rozhraní pro přepínač.
Každý port přepínače byl reprezentován vlastním ethernetovým rozhraním net\_device \ref[NETDEV], které mají společného rodiče stejného typu. %TODO uhladit

Kvůli problému v komunikaci bylo potřeba odloučit datovou strukturu DSA od platform\_driveru, což následně způsobilo rozšíření dsa\_switch\_driver \ref[mvdri].

V uvolňovací části ovladače bylo potřeba provést několik změn, jelikož v původním provedení se nepředpokládalo, že by se tento ovladač někdy uvolňoval.
To plyne z debaty na \cite[ML].
Funkce na uvolňování ovladače nebyla v původní verzi dokončena, a proto byla teď upravena část uvolňovací rutiny {\em dsa\_destroy()}, která v současné verzi podporuje uvolnění všech portů interpretovaných strukturou net\_device a interních struktur DSA ovladače, jako je struktura {\em dsa\_switch a dsa\_switch\_tree}.


\label[mvdri]

\secc Vytvoření ovladač zařízení Marvell 88E6065

Pro kontrolu zařízení Marvell 88E6065 bylo zapotřebí vytvořit ovladač, který není v současné době naimplementován v Linuxovém jádře.

Tento ovladač je instancí dsa\_switch\_driver, jak je vidět na obrázku \ref[umlDSA].
Struktura dsa\_switch\_driver obsahuje metody, které zajišťují nainicializování, uvolňení a nastavení přepínače jako celku i jeho jednotlivých portů.
%TODO rozepsat


\sec Spojení jednotlivých ovladačů


Všechny ovladače jsou implementovány tak, aby vykonávaly svou část.

Na připojení USB a přijetí ID byl zaveden ovladač AX88772b, který aktivuje vrstvu PHY. 
Po zápisu dat do souboru dsa\_bind bylo v adresáři příslušného USB zařízení aktivováno druhé rozhraní, kterým je RMII, a provedeno nainicializování DSA subsystému.
Tento subsystém tak byl schopen vytvořit dostatek ethernetových rozhraní a připojit příslušný ovladač pro přepínací obvod.

Po úspěšném spojení jednotlivých ovladačů je nyní na základě příkazů pro ethtool možné komunikovat s ovladačem skrz uživatelský prostor.

\sec Odezva komunity

Odezva komunity byla po odeslání RFC patche velmi rychlá
\fnote{\url{http://lists.openwall.net/netdev/2015/04/21/20}},
odpovědi se mi dostalo během pouhých pár hodin.
Uživatel Andrew Lunn se vyjádřil k mému nápadu a navrhl několik optimalizací.
Vyhnout se změnám v DSA subsystému a vytvořit zaobalovací ovladač pro ovladač kontroléru AX88772b.

Můj příspěvek strhl debatu o možnostech subsystému DSA v Linuxovém jádře -- subsystém DSA prý není připravené pro podporu připojování a odpojování zařízení za běhu systému.
Pravděpodobně však tato změna subsystému DSA nenastane ani v příštích verzích Linuxového jádra.
Z diskuze však vyplynulo, že se pravděpodobně celý subsystém DSA v budoucnu přepíše.

\label[TEST]

\chap Testování

Tato kapitola se zabývá testováním implementovaného řešíní zejména na propustnost a stabilitu sítě.
Jelikož se jedná o systém s podporou inicializace za běhu, je také důležité aby se v řešení neobjevovali žádné neuvolňené bloky paměti nebo aby systém s postupem času nealokoval stále více paměťi.

\sec Testování uvolňování paměti

Uvolňování paměti proběhlo několika způsoby.

Prvním způsobem bylo testování pomocí utility v Linuxovém jádře, kterou je Kernel Memory Leak Detektor
\fnote{Kernel Memory Leak Detektor je utilita v Linuxovém jadře, která umožňuje nalezení špatného uvolňení paměti. Funguje podobně jako trasující garbage collector.}.
Tato utilita sleduje naalokocané bloky a ukladá si o nich informace.
A vyhlasí chybovou hlášku, kterou můžeme vidět níže, pokud systém vymaže všechny ukazatele na tento objekt.

\begtt
unreferenced object 0xdaafbfc0 (size 64):
  comm "kworker/0:1", pid 29, jiffies 4294949812 (age 272.380s)
  hex dump (first 32 bytes):
    64 73 61 5f 62 69 6e 64 00 5a 5a 5a 5a 5a 5a 5a  dsa_bind.ZZZZZZZ
    5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a 5a  ZZZZZZZZZZZZZZZZ
  backtrace:
    [<c00b6ee0>] kstrdup+0x2c/0x54
    [<c01359f4>] __kernfs_new_node+0x28/0xc4
    [<c013691c>] kernfs_new_node+0x1c/0x38
    [<c0136c40>] kernfs_create_dir_ns+0x18/0x60
    [<c0138a60>] sysfs_create_dir_ns+0x48/0x94
    [<c0215cb0>] kobject_add_internal+0x9c/0x2d0
    [<c0216034>] kobject_init_and_add+0x48/0x70
    [<c0369184>] ax88772_bind+0x174/0x220
    [<c03741b0>] usbnet_probe+0x208/0x6b4
    [<c038a9ac>] usb_probe_interface+0x164/0x1f4
    [<c02f54c8>] driver_probe_device+0x10c/0x22c
    [<c02f3c64>] bus_for_each_drv+0x44/0x8c
    [<c02f5384>] device_attach+0x70/0x88
    [<c02f4adc>] bus_probe_device+0x84/0xa8
    [<c02f3034>] device_add+0x2ec/0x4e0
    [<c0388818>] usb_set_configuration+0x530/0x75c
\endtt

Jak lze vidět z tohoto výpisu utility Kernel Memory Leak Detektoru -- ten drží informace ke každé alokované instaci objektu a ukladá o ni informace jako trasování tj. zásobník, popisující volání funkce při alokaci objektu na který jsem zpratili reference.
Z tohoto trasování můžeme nadále vyhledat jaká funkce alokovala pamět a na základě toho opravit kód.

Chyba zmíněná výše nastala v mém kódu, kdy jsem zapoměl odregistrovat instanci kobj.
Po opravení této chyby, další neočekavané neuvolňení paměti tato utilita neobjevila.

Dalším způsobem bylo testování skriptem test.sh, který opakovaně registruje a odregistrovává ovladač.

Ten objevil chybu v přístupu ke sdílenému objektu.
Konkrétně v DSA subsystému, ten obsahuje periodickou rutinu {\em poll}, která je vyvolána časovačem.
Tato rutina periodicky vyčítá zařízení a dotazuje se ho, zdali nepotřebuje nějakou interakci.

Několikrát se stalo, že během zpracovávání funkce {\em poll} byla data se kterými pracuje funkce {\em poll}, uvolňena.
To zapříčinilo zpanikaření jádra a následný pád systému.

Po uzamčení sdílených dat, tento problém již nenastal.

\label[INIT]

\sec Inicializace zařízení

Po připojení zařízení je důležité toto zařízení nastavit, to v rámci testování probíhalo Linuxovou utilitou ifconfig a ip.
Prvním krokem po připojení zařízení je nastavení rodičovského uzlu jako aktivní, kde {\em eth1} specifikuje tento uzel.

\begtt
> ifconfig eth1 up
\endtt

Po aktivování rodičovského zařízení připojíme DSA subsystém, aby mohl být ovládán konfigurovatelný přepínač.
To bylo provedeno zapsaním do souboru {\em usb\_dsa\_bind}, který se nachází ve složce patřící k příslušnému USB zařízení v našem případě je tato cesta {\em /sys/devices/soc0/c5008000.usb/usb3/3-1/3-1.1/DSA\_BIND/dsa\_bind/usb\_dsa\_bind}.
Pak tento příkaz vypadá následovně.

\begtt
> echo 1 > /sys/devices/soc0/c5008000.usb/
     usb3/3-1/3-1.1/DSA\_BIND/dsa\_bind/usb\_dsa\_bind
\endtt

Po tomto příkazu se ovladač přepínače inicializuje a vytvoří virtuální rozhraní pro každý ze svých portů.
Zapnutí tohoto portu může probíhat například následovně, kde název rozhraní portu je {\em port1}.

\begtt
> ifconfig port1 up
\endtt

Po tomto příkazu máme aktivován {\em port1}, který má nastavenou automatickou konfiguraci rychlosti a tento port není umístěn v žádné z VLAN.

\sec Testování zařízení a výkonu

V první řádě bylo potřeba se ujistit, že přepínač je dobře nastaven.
To probíhalo kontrolou od nejnižších vrstev ISO/OSI, fyzickou, až po nějvyšší, kterou je aplikační.

Po připojení UTP kabelu mezi přepínač a počítač bylo nutné zapnout port přepínače \ref[INIT].
A zařízení by mělo začít komunikovat s počítačem a měla by proběhnout automatická konfigurace rychlosti.
Jak je možné vidět níže z výpisu nástroje ethtool.

\begtt
> ethtool eth0
Settings for eth0:
	Supported ports: [ TP MII ]
	Supported pause frame use: No
	Supports auto-negotiation: Yes
	Advertised pause frame use: Symmetric Receive-only
	Advertised auto-negotiation: Yes
	Link partner advertised link modes:  10baseT/Half 10baseT/Full 
	                                     100baseT/Half 100baseT/Full 
	Link partner advertised pause frame use: No
	Link partner advertised auto-negotiation: Yes
	Speed: 100Mb/s
	Duplex: Full
	Port: MII
	PHYAD: 0
	Transceiver: internal
	Auto-negotiation: on
	Link detected: yes
\endtt

Po připojení dalšího zařízení a aktivování dalšího z portů mohla být testována komunikace mezi zařízeními skrze konfigurovatelný přepínač.
Mezi nejzákladnější testy připojení patří ping, který je jenden z kontrolních zpráv ICMP protokolu.

\begtt
> ping 192.168.202.222
PING 192.168.202.222 (192.168.202.222) 56(84) bytes of data.
64 bytes from 192.168.202.222: icmp_seq=1 ttl=64 time=0.368 ms
...
--- 192.168.202.222 ping statistics ---
11 packets transmitted, 9 received, 18% packet loss, time 9997ms
rtt min/avg/max/mdev = 0.368/0.424/0.466/0.042 ms
\endtt

Jak je vidět na výpisu, zařízení úspěšně poskalo ICMP paket ping a také na něj dostalo odpověd ICMP paketu PONG.
A nyní bylo možno otestovat přenos dat na reálných datech, která byla pro tento účel brána z nulového zařízení {\em /dev/null}.

Pro zpuštění testu bylo nutno na jednom ze dvouch počítačů zapnout server, který bude naslouchat na portu 4242:

\begtt
> nc -lk -z 4242 > /dev/null
\endtt

A na druhém z počítačů bylo nutno zapnout přenos dat na druhý počítač s danou IP adresou a daným portem, tak jak můžeme vidět na výpisu níže:

\begtt
> dd if=/dev/zero bs=16000 count=625 | nc -v 192.168.202.222 4242
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
10000000 bytes (10 MB) copied, 0.877273 s, 11.4 MB/s
\endtt

Na tomto příkaldě bylo odesláno 10~MB dat v 625 paketech, která byla přenesena rychlostí 11.4~MB/s.

\begtt
> dd if=/dev/zero bs=160000 count=625 | nc -v 192.168.202.222 2112
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
100000000 bytes (100 MB) copied, 8.49099 s, 11.8 MB/s
> dd if=/dev/zero bs=1600000 count=625 | nc -v 192.168.202.222 2112
192.168.202.222 2112 (idonix-metanet) open
625+0 records in
625+0 records out
1000000000 bytes (1.0 GB) copied, 85.9629 s, 11.6 MB/s
\endtt

Tyto testy také byla prováděny na různých velikostech a rychlost přenosu se pohybovala mezi 11.3~MB/s až 11.9~MB/s.


\begtt
[11.046] Unable to handle kernel paging request at Virtual Addr 6b6b6b77
[11.053] pgd = c0004000
[11.055] [6b6b6b77] *pgd=00000000
[11.059] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
[11.064] Modules linked in:
[11.067] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.19.0 #298
[11.075] Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
[11.082] task: c08ba2a8 ti: c08ae000 task.ti: c08ae000
[11.087] PC is at get_next_timer_interrupt+0xa0/0x294
[11.092] LR is at get_next_timer_interrupt+0x60/0x294
[11.098] pc : [<c006f474>]    lr : [<c006f434>]    psr: 90000093
[11.098] sp : c08aff00  ip : 6b6b6b6b  fp : 00000000
[11.109] r10: c0927540  r9 : ffff8f21  r8 : ffff8f20
[11.114] r7 : 00000000  r6 : 3fff8f1f  r5 : ffff8f20  r4 : ffff8f17
[11.121] r3 : 6b6b6b6b  r2 : 00000021  r1 : 00000023  r0 : c0927674
[11.127] Flags: NzcV IRQs off FIQs on Mode SVC_32 ISA ARM Segment kernel
[11.135] Control: 10c5387d  Table: 1ac0404a  DAC: 00000015
[11.140] Process swapper/0 (pid: 0, stack limit = 0xc08ae238)
[11.146] Stack: (0xc08aff00 to 0xc08b0000)
[11.151] ff00: c08affa4 c060ecc0 0000001d c00625f0
    fe44010c 0000000d c08aff40 c08b7154
[11.159] ff20: 755c2278 00000002 c08ac640 60000000
    00000185 dbbb4280 00000000 ffff8f20
[11.216] [<c006f474>] (get_next_timer_interrupt)
    from [<c007e34c>] (__tick_nohz_idle_enter+0x2d4/0x41c)
[11.226] [<c007e34c>] (__tick_nohz_idle_enter)
    from [<c007e4e0>] (tick_nohz_idle_enter+0x30/0x6c)
[11.235] [<c007e4e0>] (tick_nohz_idle_enter)
    from [<c00552c4>] (cpu_startup_entry+0x18/0x278)
[11.244] [<c00552c4>] (cpu_startup_entry)
    from [<c0868c0c>] (start_kernel+0x360/0x3cc)
\endtt

%\sec Zhodnocení

\chap Závěr

Cílem mé diplomové práce bylo vytvoření ovladače do operačního systému Linux pro přepínač založený na bázi Ethernetu, který by splňoval industriální teplotní rozsahy.
Tyto přepínače se v dnešní době téměř nevyrábějí a moduly, které by splňovaly tyto teplotní rozsahy a měly integrované MII rozhraní pro připojení fyzické vrstvy, jsou finančně velmi nákladné.
Proto se tato práce zabývá možností připojení ethernetového přepínače pomocí USB sběrnice.

Vytvoření tohoto ovladače bylo zadáno firmou Retia a.s. se sídlem v Pardubicích.
Zadání bylo vytvořeno za účelem nahrazení staršího modelu konfigurovatelného přepínače, který splňuje industriální teplotní rozsahy, za výkonnější.
Firma poskytla pro tuto práci modul Colibri T20 a konfigurovatelný přepínač i s návrhem.
Deska konfigurovatelného přepínače byl založen na přepínacím obvodu 88E6065 a je vyvinut firmou Marvell a byl připojen USB--ethernetovým kontrolérem AX88772b, vyraběným firmou Asix, který podporuje připojení fyzické vrstvy za pomoci rozhraní RMII.

Pro vytvoření ovladače byla naportována nejnovější verze operačního systému Linux na modul Colibri T20, který má integrované hostitelské USB zařízení a splňuje industriální teplotní rozsahy.
Dálé byl implementován ovladač pro přepínač do této verze operačního systému, který umožňuje inicializaci zařízení za běhu a umí reprezentovat každý port přepínače jako virtuální rozhraní v uživatelském prostoru operačního systému Linux.

Tento ovladač byl složen z úpravy stávajícího ovladače pro kontrolér AX88772b, který byl rozšířen o podporu menežovacího rozhraní RMII.
Další úpravou prošel subsystém DSA, který byl doplňen o možnost uvolňení zařízení za běhu a také jeho připojení.
K implementaci ovladače pro menežovatelný přepínač taky patří ovladač pro čip ethernetového přepínače Marvell 88E6065, který řídí tento obvod.
Implementace byla provedena na současné verzi Linuxového jádra s pokusem dostat tuto upravu do hlavní větve Linuxového jádra.
Kde bylo navrženo nějakolik úprav, vylepšení a chyb, které se vyskytli v ovladači.

V této práci byl vytvořen ovladač ethernetového přepínače, který úspěšně zavede přepínač a vytvoření pro něj rozhraní viditělná z uživatelského prostoru.
V další práci by bylo dobré rozšiřit funkčnost tohoto ovladače, aby podporoval více funkcí.

%funguje, odezva, linuxova komunita, dosazene vysledky, vykon
%MII,RMII,GMII,RGMII,SGMII,QGMII,XAUI


