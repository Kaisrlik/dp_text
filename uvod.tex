\chap Úvod


Přepínače založené na bázy ethernetu, které splňují industriální teplotní rozsahy se téměř v dnešní době nevyrábějí.
A moduly splňující tyto rozsahy, které mají integrované MII rozhraní, pro připojení fyzické vrstvy, jsou jiných cenových kategoriích.
Proto tato práce přináší možnost připojení k ethernetového přepínače z pomocí USB sběrnice. A ovladače pro tento přepínač založené na operačím systému Linux.

Tato práce se zabívá portací operačního systému Linux na modul Colibri T20, který má integrované hostitelské USB zařízení.
Dálé sezabívá implementací ovladače do operačního systému Linux pro zařízení na bázi přepínacího obvodu 88E6065 vyvíjené firmou Marvell, který je připojen USB kontrolérem AX88772b od firmy Asix, která splňují industriální rozsah teplot.


Práce v první kapitole \ref[pouztech] popisuje použitou technologii jako je sběrnice USB \ref[USB],  MII rozhraní \ref[MII] a, rozšířená verze MII rozhraní, RMII \ref[RMIIsub].
Konkrétně popisuje k čemu se tyto technologie používají, jaké mají omezen a způsob komunikace.
Tato kapitole též popisuje Linuxový subsystém \ref[LINUXsub]. Konkrétně část ethernetového, usb subsystému a subsystém přepínače.

V kapitole Použitý Hardware \ref[pouzhw] se můžeme dozvědět o použítém modulu a vyrobené desce ethernetového přepínače.
A čipů použitých na této desce jako je USB kontrolér a přepínací obvod.

Kapitola Implementace \ref[impl] popisuje nahraní nového Linuxového jádra a oživení desky.
Dále pak obsahuje návrh ovladačů pro operační systém Linux a jeho následnou implementaci.

V poslední kapitole Testování \ref[TEST] se popisují jednotlivé testy ovladače.
A vyhodnocují se výsledky na těchto testů.


\label[pouztech]

\chap Použité technologie

Tato kapitola je rozebírána použitá technologie.
V první části je rozebrána sběrnice USB \ref[USB].
Další významnou sekcí je rozhraní Media Independent Interface, který předpokládá znalost modelu OSI, který je tu též uveden.
Ke konci této kapitoly bylo rozepsáno jak vypadájí ovladače v linuxu a tvář linuxového subsystému Distributed Switch Architecture a k němu přilehlé subsystémy.

%LDD3 pekny popis zarizeni http://www.makelinux.net/ldd3/?u=chp-13-sect-4
%MAC podporuje 802.3 a 802.3u MAC funkce, jako je prijem a odeslani ramce, kontrolu CRC, duplex mode, forwarding, flow-control, detekce kolizi atd.

%\label[ISO]
%\sec Model ISO/OSI
%Model ISO/OSI je konceptuální model, který charakterizuje komunikačních sítích. Rozdělaná do vrstev.

\label[USB]

\sec Univerzální Sériová Sběrnice

Univerzální Sériová Sběrnice je technický standard vyvíjený od roku 1994 pro připojení periferií k počítači.
Tato sběrnice měla nahradit pomalé sběrnice (jako jsou seriová linka, paralelní port, PS2 a mnohé další) jednou sběrnicí \cite[LDD3].
V dnešní době USB umožňuje přenášet velké množství dat s rychlostí až 640 MB/s u USB zařízení verze 3.0.
Díky tomu se použití USB rozšířilo a nyní podporuje skoro každý druh zařízení, která umožňují přenašet video, audio a dokonce i ethernetové rámce a pakety.
Podporovaná zařízení jsou rozdělena do tříd z důvodu sjednocení funkcionality a chovaní zařízení.
Nejznámějšími třídami jsou HID, Printer a Mass Storage, které jsou více popsány ve vývojářské dokumentaci \ref[USB].
Toto sjednocené chování má za důsledek společných ovladačů, která tato zařízení mohou využívat.
Problém s některými druhy zařízení je takový, že je nejde do daných tříd zařadit, popřípadě mají rozšířené chování a potřebují speciální přístup.

\secc Rysy USB zařízení

USB je deterministická sběrnice (Master/Slave), která podporuje detekci připojeného zařízení za běhu (plug\&play) a následnou automatickou konfiguraci (hotswap).
USB síť se zkládá ze třech druhů zařízení \cite[USB]:
\begitems
*Hostitel -- je zařízení typu Master a je jako jediný v systému, řídí komunikaci a obvykle integruje rozbočovač označen jako kořenový.
Přiděluje zařízením unikátní adresu v síti.
*Rozbočovač -- distribuuje datové toky a identifikuje připojení a odpojení dalších zařízení.
*Zařízení -- Pojmem zařízení je míňeno koncové zařízení s požadovanou funkcionalitou, které odpovídá na kontrolní zprávy.
\enditems

USB je asymetrická sběrnice s jedním zařízením typu Master, která spíše vypadá jako strom složený z linek bod-bod.
Přičemž USB huby vytvářejí jednotlivé uzly tohoto stromu a zařízení tvoří jejich listy.
Linky USB sběrnice jsou 4 vodičové obsahující diferenciální pár datových linek, napěťový a zemnící vodič, které připojují zařízení a USB huby.
USB umožňuje připojit až 127 zařízení v rámci jedné USB sítě o hloubce maximálně pěti rozbočovaču.


USB je asymetrická sběrnice, kterou lze popsat jako strom složený z linek bod-bod.
USB huby vytvářejí jednotlivé uzly tohoto stromu a zařízení tvoří jejich listy.
USB umožňuje připojit až 127 zařízení v rámci jedné USB sítě o hloubce maximálně pěti rozbočovačů, tak jak můžeme vidět na obrázku \ref[USBhub].

\medskip
\clabel[USBhub]{USB tier.}
\picw=13cm \cinspic images/technet.microsoft.com.jpg
\caption/f Obrázek popisuje jak lze USB zapojit \cite[MSTECH].
\medskip

Linky USB sběrnice jsou 4 vodičové vedení obsahující diferenciální pár datových linek, napěťový a zemnící vodič, která připojují zařízení a USB huby.

Díky tomu USB umožňuje jednoduchý mechanismus detekce a enumerace, neboli průběhu konfigurace (více informací níže \ref[USBkom]), za běhu systému, který je řízen a konfigurován automaticky hostitelem.


\label[USBkom]

\secc Komunikace

USB komunikace je založena na logických kanálech tzv. rourách. Každému výstupnímu kanálu by měl odpovídat právě jeden vstupní.
Koncový bod obsahuje rouru s definovaným směrem.

USB muže mít maximalně 30 koncových bodů. Koncový bod je roura s definovaným směrem.
Tyto koncové body jsou inicializovány v průběhu enumarace USB zařízení, které probíhá po kontrolní rouře označené číslem 0, kterou mají všechna zařízení společnou.
Každý koncový bod obsahuje rouru s předem definovaným typem přenosu:

\begitems
*Řídící -- Obousměrná roura sloužící ke konfiguraci zařízení. Každé zařízení disponuje tímto druhem roury. Má rezervovanou určitou přenosovou kapacitu.
*Izochronní - Jednosměrná roura sloužící ke stálému přenosu většího objemu dat. Má garantovanou latenci, přenos však není spolehlivý. Tento typ roury je vhodný pro audio a video.
*Přerušovací - Jednosměrná roura sloužící pro časté přenosy malého množství dat. Má garantovanou šířku pásma. A přenos dat je spolehlivý. V případě chyby se přenos opakuje.
*Blokový - Jednosměrná roura sloužící k přenosu velkého množství dat. Nemá rezervovanou žádnou přenosovou kapacitu ani dobu odezvy. Komunikace po této rouře je spolehlivá a v případě chyby se přenos opakuje.
\enditems

Enumerace je posloupnost standardizovaných příkazů, kterou započal hostitel.
V průběhu enumerace se předávají deskriptory, které obsahují důležité informace o zařízení.
Hierarchiji deskriptorů můžeme vidět na obrázku \ref[USBhier].

\medskip
\clabel[USBhier]{Hierarchije USB deskriptorů.}
\picw=13cm \cinspic images/IMG019.pdf
\caption/f Obrázek popisuje jak lze USB zapojit \cite[LUSB].
\medskip


\begitems
*Dekriptor zařízení -- Obsahuje informace jako je ID vyrobce a produktu.
Též obsahuje informace o třídě a maximalní delku paketů, které může roura 0 přijmout.
*Konfigurační deskriptor -- Oznamují jak mají být napájeni, maximální proud, počet rozhraní. Těchto dekriptorů může být více.
*Deskriptor rozhraní -- Tento dekriptor informuje o funkcionalitě celého celku jako je třídá koncových zařízení a počet koncových bodů.
*Deskriptor koncového bodu --Používá se k přesnémuj popisu koncového bodu.
*Textový dekriptor -- Tento dekriptor přenáší pouze čitelné informace o zařízeních kódované v Unicodu
\enditems

Na základě informací v deskriptorech se operační systém rozhoduje, který druh ovladače přiřádí danému druhu zařízení.


\medskip \medskip \medskip \medskip

\label[MII]

\sec Media Independent Interface

Media Independent Interface (MII) je typ rozhraní, který umožňuje připojení nezávislé na procesoru a fyzickém médiu.
Tento typ rozhraní je specifikován standardem IEEE 802.3, který je popsán v kapitole 22 \cite[IEEE8023].
MII propojuje dvě vrstvy modelu ISO/OSI, a to vrstvu spojovou, konkrétně její část Media Access Constroll (MAC),
\fnote{MAC je popsána standardem IEEE 802.2001. Stará se o přijímaní a odesílání rámců(přístup k mediu), ochranu proti chybám}
s vrstvou fyzickou (PHY)
\fnote{PHY převádí bitový stream na signál a definuje jeho doručení.}.
MII rozhraní podporuje dva datové toky - 10~Mb/s a 100~Mb/s.
Na obou datových tocích je funkcionalita MII identická, liší se pouze v nominální frekvenci hodin.
Vyšší rychlosti přenosu je možno dosáhnout změnou rozhraní na Gigabite Media Independent Interface, které podporuje rychlost až 1~Gb/s.

\medskip
\clabel[MIItoISO]{Spojitost mezi MII a OSI/OSI}
\picw=16cm \cinspic images/802_iso.pdf
\caption/f Obrázek popisuje spojitost mezi rozhraním MII, modelem OSO/OSI a modelem IEEE 802.3 CSMA/CD LAN \cite[IEEE8023].
\medskip

Na obrázku \ref[MIItoISO] je vidět připojení MII na Reconsiliation Sublayer (RS) a PCS nebo PLS.%rozepsat zkratky
RS je podvrstva, která mapuje signály z MII na MAC/PLS obsluhu.
PLS a PCS jsou vrstvy, které se starají o kódování a dekódování signálů.
Konkrétní mapování MII signálů znázorňuje obrázek \ref[RStoMII].

\medskip
\clabel[RStoMII]{Mapování signálů RS na MII}
\picw=15cm \cinspic images/802_rs.pdf
\caption/f Obrázek popisuje, jak RS mapuje signály mezi MII a PLS. Také lze vidět připojení STA \cite[IEEE8023].
\medskip

Jak můžeme vidět na obrázku \ref[RStoMII], fyzické rozhraní MII se skládá ze dvou druhů sběrnic, a to datové \ref[MIIdat] a menežovací (STA) \ref[MDIOs].
STA může být připojeno až k 32 fyzickým jednotkám. které obsluhuje.

\label[MIIdat]

\secc Datová část MII rozhraní

Datová část MII disponuje několika druhy signálů, které lze vidět na pravé straně obrázku \ref[RStoMII]. 
Tyto signály jsou připojeny k přemapovací vrstvě RS.
Druhy datových signálů:

\begitems
*TX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech TX\_EN, TXD a TX\_ER.
Zdrojem signálu TX\_CLK je PHY. 
Frekvence tohoto signálu by měla být 20\% z nominální hodnoty přenosu dat +- 100ppm. %TODO plus minus
*RX\_CLK -- pin vysílající referenční hodinový signál pro synchronizaci signálů vysílaných po pinech RX\_DV, RXD a RX\_ER.
Zdrojem signálu RX\_CLK je RS. %XXX kouknout na manuál
RX\_CLK může odvodit referenční hodnotu z přijímaných dat nebo z nominální hodnoty jako u signálu pinu TX\_CLK.
*TX\_EN -- pin vysílající signál, který indikuje, že je RS připravena odesílat data.
*TDX -- čtveřice datových pinů vysílající signál (TDX[3:0]) ovládaná podvrstvou RS, která přenáší data synchronně na základě signálu z pinu TX\_CLK. 
TDX[0]  přenáší nejméně významný bit.
Pokud je TX\_EN fyzicky odpojen, TDX nemá žádný efekt na činnost PHY.
*TX\_ER -- pin vysílající signál řízený podvrstvou RS, který indikuje. že PHY začala vysílat jeden či více symbolů, které nejsou součástí dat, nebo že předčasně došlo k přerušení rámce.
Signál na tomto  pinu je synchronní s hodinovým signálem z pinu TX\_CLK.
*RX\_DV -- pin vysílající signál, který značí, že přijatá data jsou validní. Tento signál je řízen PHY a je synchronní se signálem z pinu RX\_CLK.
*RXD -- čtveřice datových pinů vysílající signál (RDX[3:0]) ovládaná vrstvou PHY, která slouží k přenosu dat z vrstvy PHY do podvrstvy RS.
RXD[0] přenáší nejméně významný bit.
*RX\_ER -- pin vysílající signál řízený vrstvou PHY, který indikuje, že nastala chyba detekovaná v průběhu přijímání rámce.
Pokud je pin RX\_DV odpojen, nemá žadný vliv na činnost podvrstvy RS.
*CRS -- pin vysílající signál indikující, zda je příjemce nebo odesílatel zaneprázdněn, nebo je ve stavu idle.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování. %XXX asi smazat
*COL -- pin vysílající signál, který je vyvolán vrstvou PHY, indikující kolize, které nastaly na médiu.
Signál z pinu není synchronizován se signálem z pinů TX\_CLK,  RX\_CLK.
Pokud je bit z registru \ref[miireg] 0.8 aktivní, signál na pinu má nedefinované chování.
\enditems
%Reprezentuje pokud josu data na odeslani nebo prijeti.

\medskip
\clabel[transiotionMII]{Komunikace po MII bez kolize.}
\picw=15cm \cinspic images/802_miicom.pdf
\caption/f Obrázek znázorňuje, jak vypadá bezchybná komunikace po MII \cite[IEEE8023].
\medskip

Na obrázku \ref[transiotionMII] lze vidět, jak vypadá komunikace po MII rozhraní.
Pin TX\_CLK přenáší referenční hodinový signál, který se pravidelně mění.
Při odesílání dat se nahodí signál z pinu TX\_EN, který začne odesílat preambuly.
Přenos těchto dat je popsán níže.
S přijímaním signálu začne být příjemce zaneprázdněn, a proto nahodí signál z pinu CRS.
Celá komunikace probíhá pouze jedním směrem a neobsahuje žádnou chybu, jak je možno vidět ze signálu na pinu COL.

Rámec dat, který je přenášen po MII rozhraní, je doplněn o hlavičky a patičky popsáné formátem:

\begtt
<vstupní rámec><preambule><sdf><data><edf>
\endtt

Kde jednotlivé položky mají následující význam:

\begitems
*vstupní rámec -- je perioda mezi rámci, při které nesmí dojít k žádné činnosti na rozhraní MII.
Tato perioda není přesně specifikována.
*preambule -- je definovaná posloupnost dat, která se skládá ze 7 oktetů (bytů) a je přenášena ve formě pravidelného střídání jedniček a nul.
*sdf -- oktet, který oznamuje začátek rámce.
*data -- značí přenesená data.
*efd -- konec rámce, který provede shození signálu na pinu TX\_EN.
\enditems

Rámce jsou přenášeny tak, že oktet je rozdělen na dvě poloviny tzv. nibbles.
Tyto poloviny jsou odeslány po datových linkách TXD nebo RXD.
Příklad odeslání oktetu po pinech TDX je znázorněn na obrázku níže \ref[NIBBLE].

\medskip
\clabel[NIBBLE]{Rozdělení oktetu po datových pinech}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_nibble.pdf
\caption/f Obrázek popisuje, jak je rozdělen byte, který je následně odeslán po pinech TDX \cite[IEEE8023].
\medskip


\label[MDIOs]

\secc Menežovací rozhraní a příslušný registrový prostor

Menežovací část sběrnice, která se značí STA, se používá k nastavování a čtení hodnot mezi vrstvamy MAC a PHY.
Toto rozhraní je dvoulinkové sériové a obsahuje dva datové vodiče:
\begitems
*MDC -- pin vysílající signál určující časovou základnu pro signál vysílaný pinem MDIO.
Signál z pinu MDC je aperiodický, nemá žádnou minimální ani maximální frekvenci, měl by se však pohybovat v rozmezí od 160~ns do 400~ns.
*MDIO -- pin vysílající signál. Tento pin je vstupně výstupní a jsou po něm posílány signály oběma směry.
Je tvořen třístavovým obvodem mezi vrstvami PHY a STA.
Pin se používá k přenosu kontrolních zpráv mezi zařizeními.
Přenos je řízen z vrstvy PHY.
Signál z pinu MDIO je synchronizovaný se signálem z pinu MDC.
\enditems

Formát menežovacích rámců je popsán v tabulce \ref[MDIOframe].
Data z této tabulky jsou odesílána po pinu MDIO ve směru z levé strany tabulky do pravé.

\midinsert \clabel[MDIOframe]{Formát menežovacích rámců.}
\ctable{lllllllll}{
 \hfil            & PRE & ST & OP & PHYAD & REGAD & TA & DATA & IDLE \crl \tskip4pt
          čtení   & 1...1 & 01 & 10 & AAAAA & RRRRR & Z0 & D...D & Z \cr
          zápis   & 1...1 & 01 & 01 & AAAAA & RRRRR & 10 & D...D & Z \cr
}
\caption/t Tabulka popisuje formát menežovacích zpráv \cite[IEEE8023] (Tabulka 22-12).
\endinsert

V tabulce \ref[MDIOframe] lze vidět hodnotu preambule (PRE), což je posloupnost 32 bitů skládajících se z hodnot logických jedniček.
Preambule slouží k synchronizaci signálu z pinu MDC.
Začátek rámce je označený ST a má hodnotu 01.
Poté jsou odesílána data popisující operační kód (OP), která určují druh operace: čtení nebo zápis.
PHYAD je zkratka pro fyzickou adresu zařízení o délce 5 bitů.
Tím dokážeme naadresovat až 32 zařízení.
První bit adresy je nejvíce významný.
Další položkou je adresa registru (REGAD) číslovaná podle níže uvedených registrů.
Dalším blokem je TA.
Při operaci čtení hodnota TA obsahuje stav vysoké impedance (Z) sloužící k prohození příjemce za odesílatele, jak lze vidět na obrázku \ref[mdioread].
Prohození  probíhá z důvodu požadavku odpovědi na operaci čtení tj. hodnoty z registru.
Při operaci zápis tato změna není potřeba a stav vysoké impedance je nahrazen logickou jedničkou.
Odesílaná data mají 16 bitová hodnotu, tedy stejnou jako je velikost registrů.

\medskip
\clabel[mdioread]{Čtení registru po STA.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/802_miimdio.pdf
\caption/f Obrázek ukazuje čtení z registru při komunikaci po sériové lince STA \cite[IEEE8023].
\medskip

Operacemi čtení a zápis může vrstva MAC přistupovat k registrovému prostrou na PHY, který tak může měnit.
Část tohoto registrového prostoru je definována standardem 802.3.
Registrový prostor obsahuje dva základní sety registrů -- kontrolní a stavový.
Všechny PHY, které podporují MII, by měly používat právě tuto sadu registrů \ref[miireg].


\medskip
\clabel[miireg]{Registry STA rozhraní.}
\picw=15cm \cinspic images/802_miireg.pdf
\caption/f Obrázek popisující registry STA rozhraní. Obrázek je převzat z~\cite[IEEE8023].
\medskip


Tyto registry specifikují základní vlastnosti PHY pro MII rozhraní o rychlostech 100~Mb/s a 1~Gb/s.
Registry 2 -- 14 jsou částí rozšířeného registrového prostoru \cite[IEEE8023] (22.2.4).
Bližší popis stavového a kontrolního registru je uveden v příloze \ref[MIIcntr] a \ref[MIIstat].


% Ne do DP
%\sec GMII

%The Gigabit Media Independent Interface (GMII) is similar to the MII. The GMII uses the MII management interface and register set specified in 22.2.4. These common elements of operation allow Station Management to determine PHY capabilities for any supported speed of operation and configure the station based on those capabilities. In a station supporting both MII and GMII operation, configuration of the station would include enabling either the MII or GMII operation as appropriate for the data rate of the selected PHY. Most of the MII and GMII signals use the same names, but the width of the RXD and TXD data bundles and the semantics of the associated control signals differ between MII and GMII operation. The GMII transmit path clocking also differs significantly from MII clocking. MII operation of these signals and clocks is specified within Clause 22 and GMII operation is specified within Clause 35.
%GMII obsahuje 3ti zakladni registr Extended status reg(15)

\label[RMIIsub]

\secc Reduce Media Independent Interface

Reduce Media Independent Interface (RMII) je obdoba rozhraní MII, která má ale snížený počet pinů z 16 na 8 \cite[RMII].
RMII přidává pouze reconciliation layer (RS), a to buď jako novou, která je připojena za stávající RS, nebo jako náhradu aktualní RS v MII \cite[RMIIcon].

Rozšířenou RS lze vidět na obrázku \ref[RMIIRS].

\medskip
\clabel[RMIIRS]{Rozšíření MII o další RS.}
\picw=15cm \cinspic images/rmiirs.pdf
\caption/f Obrázek, který znázorňuje rozšíření MII o další vrstvu RS.  Obrázek je převzat z~\cite[RMII].
\medskip

RMII používá stejné menežovací rozhraní jako MII definované standardem IEEE 802.3u \cite[IEEE8023], který je popsán v sekci \ref[MDIOs].

Hlavními rozdíly RMII oproti MII jsou datové piny TXD a RXD. které jsou v RMII pouze 2 bity široké.
Dále signály z pinů COL a CRS jsou zde sjednoceny do jednoho signálu na pinu CRS\_DV.
Dalším rozdílem je detekce kolizí, která je na vrstvě MAC provedena jako logický součin signálů TX\_EN a CRS\_DV.
Zdrojem hodinového signálu je vrstva MAC nebo je generován externími hodinami.


% TODO
%\sec linux

%\sec info kernel

%\sec loading proces

%\sec disribuce

%\secc openwrt

\medskip \medskip \medskip \medskip

\label[LINUXsub]

\sec Subsystém operačního systému Linux

Tato kapitola obsahuje informace o tom, co to je ovladač, a dále popisuje základní stavební prvky naimplementováné v operačním systému Linux: device, mii\_bus, net\_device, DSA a sysfs.

\secc Co je to ovladač

Ovladač je část programu (algoritmu), která spravuje nebo kontroluje určité zařízení připojené k počítači.
Ovladače vytvářejí softwarové rozhraní pro hardwarové zařízení, která umožňují operačnímu systému ovládat tento hardware, aniž by uživatel věděl, jak přesně funguje \cite[LDD3].

\secc device

Každé zařízení naimplementované na nejnižší úrovni je v operačním systému Linux reprezentováno instancí struktury {\em device}.
Struktura device obsahuje informace o tom, co zařízení potřebuje, aby správně fungovalo v systému.
Mnoho subsystémů uchovává informace o struktuře device a tyto informace využívají k dalším procesům.
V dnešní době je velmi obtížné nalézt zařízení, které je reprezentováno pouze struktorou {\em device}.
Místo toho  některé instance v struktuře {\em device}, jako je kobj, obecně implementují výše reprezentovaná zařízení \ref[DEV]. %XXX divny
\fnote{Popis datové struktury {\em device} lze nalézt na \url{http://lxr.free-electrons.com/source/include/linux/device.h\#L730}}.

\secc mii bus

{\em Struct mii\_bus} je struktura, která reprezentuje MII rozhraní a umožňuje přístup k registrům popsaným v \ref[miireg].

\label[DSA]

\secc Distributed Switch Architecture

Distributed Switch Architecture (DSA) je rozhraní pro menežování hardwarových přepínačů \cite[DSA].
%Obsahuje MII menežovací registry, příkazy pro nastavení přepínače a formát ethernetových hlaviček, který signalizuje na kterém portu byl paket přijat nebo ktery se hodlá odeslat 
Tento subsystém podporuje přepínače, které jsou připojeny způsobem zobrazeným na obrázku \ref[DSAcon].

\medskip
\clabel[DSAcon]{Připojení DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Tento subsystém reprezentující přepínače interpretuje každý port jako oddělené síťové rozhraní \ref[NETDEV].
Nastavování přepínače, jako je stav portů a menežment MII rozhraní, je provedeno na základě rozhraní ethtool \fnote{Ethtool je standardní utilita Linuxu pro ovládání a podporu ovladačů a zařízení.}.

Subsystém DSA podporuje i propojení mezi přepínači tak, jak je možno vidět na obrázku \ref[DSAcon2].
Takto propojené přepínače lze ovládat skrz MII rozhraní.

\medskip
\clabel[DSAcon2]{Připojení více přepínačů DSA k CPU.}
%\picw=13cm \cinspic MIItoISO.png
\picw=15cm \cinspic images/DSAcon2.pdf
\caption/f Obrázek popisuje, jak je možné připojit DSA přepínač k procesoru. Obrázek je převzat z~\cite[DSA].
\medskip

Na obrázku \ref[umlDSA] je diagram tříd důležitých struktur v subsystému DSA, které jsou nezbytné pro funkčnost subsystému.

\medskip
\clabel[umlDSA]{Diagram tříd DSA subsystému.}
\picw=15cm \cinspic images/dsa_uml.pdf
\caption/f Na obrázku můžeme vidět popis vybraných datových struktur.
\medskip

Na tomto obrázku jsou zvýrazněny struktury {\em mii\_bus}, {\em net\_device} a {\em dsa\_platform\_data}.
Tyto struktury DSA subsystém nevytváří, a proto je potřeba tyto struktury předat subsystému.

%XXX upravit aby to bylo více vypovídající
Subsystém DSA je reprezentován strukturou {\em dsa\_switch\_tree}, která obsahuje odkazy na struktury:
\begitems
*dsa\_platform\_data -- tato struktura informuje o tom, jaká zařízení jsou připojená ke kořenovému přepínači.
Také obsahuju strukturu {\em dsa\_chip\_data} popsanou níže.
*net\_device -- tato struktura odkazuje na hlavní síťové zařízení \ref[NETDEV].
*dsa\_switch -- obsahuje data pro jednotlivé přepínače popsané níže.
\enditems

Struktura {\em dsa\_switch} nesoucí data o připojeném přepínači obsahuje následnující data:
\begitems
*dsa\_switch\_tree -- je odkaz na rodičovskou strukturu.
*dsa\_chip\_data -- struktura obsahující informace o fyzickém přepínači -- kolik má portů a jaké jsou jejich názvy.
Navíc obsahuje informace o device tree \fnote{Device tree je popis hardwarového zařízení v kódu.}.
*device -- je odkaz na hostovské zařízení, které se právě využívá.
*dsa\_switch\_driver -- struktura popisující ovladač přepínačů, obsahuje funkce na menežování připojeného přepínače.
*mii\_bus -- je ovladač MII sběrnice.
*net\_device -- je odkaz na síťové zařízení \ref[NETDEV] reprezentující port zařízení.
\enditems


\label[NETDEV]

\secc net device

Struktura {\em net\_device } popisuje síťové rozhraní \cite[ULNI].
Síťové rozhraní může přijímat a vysílat velké množství dat, a proto je implementace podobná diskovým zařízením \cite[LDD3].
Síťová zařízení přijímají data asynchronně a ukládájí je do vyrovnávací paměti.

V linuxovém jádře je síťový subsystém naimplementován tak, že je na protokolu nezávislý.


%TODO XXX knizka
%Struktura {\em net\_device } může být klasifikována do několika kategorií:
%\begitems
%*Konfigurace -- něterá konfigurace je dána Linuxovým jádrem a nějaké jsou možné nastavit programamy z uživatelského rozhraní jako je ifconfig a ip.
%*Statistiky -- Statistyky jako počet odeslaných paketů a paketů přiajtých, popsané v struktuře, která se jmenuje priv.
%*Stav zařízení
%*Menežování přenosu -- Nastavení kvality služeb (QoS).
%*Odkazy na funkce -- Tyto ukazatele jsou implemntovány ovladači zařízeních. Obsahují funkce jako je nahození portů, shození portů, nastavení adres a mnohé další popsané v dokumentaci Linuxového jádra nebo \cite[ULNI].
%\enditems


\label[USBst]

\secc usb ovladač

Linuxové jádro podporuje dva druhy USB zařízení -- ovladače na hostovském systému a ovladače na zařízení \cite[LDD3].
USB ovladač na hostovském systému pracuje na systému, ke kterému je USB zařizení připojeno.
Ovladač na zařízení, neboli \"USB gadget drivers\" , je připojojen k hostovskému systému a chová se jako hostovská stanice připojena přes USB. %TODO opravit vetu
Na obrázku níže můžeme vidět USB hierarchii, kde USB může existovat v několika různých subsystémech (net, block, char ...).
USB jádro implementuje rozhraní pro USB ovladače, které chtějí kontrolovat hardware a přistupovat k němu.

Koncové body USB jsou popsány v jádře Linuxu strukturou {\em usb\_host\_endpoint}.
Tato struktura obsahuje informace o reálném koncovém bodu ve struktuře {\em usb\_endpoint\_descriptor}.
Struktura {\em usb\_endpoint\_descriptor} popisuje data pomocí přijatých deskriptorů.

\medskip
\clabel[USBMAP]{Hierarchie USB.}
\picw=15cm \cinspic images/usbendpmap.pdf
\caption/f Na obrázku lze vyčíst hierarchii USB prvků. Obrázek převzat z \cite[LDD3]. %TODO popisek
\medskip


USB rozhraní je složeno z několika koncových bodů, které tvoří jedno logické připojení jako je napřiklad myš, klávesnice, video atd.
Některá USB zařízení však mohou mít více rozhraní.
Například USB repoduktory mohou mít dvě rozhraní, jako je USB klávesnice pro tlačítka reproduktoru a USB audio pro jeho zvuk \cite[LDD3].%TODO presunout nahoru
Linuxové jádro používá pro každé rozhraní právě jeden hardwarový ovladač.
Toto rozhraní je popsáno strukturou {\em usb\_interface}.
Tato struktura je to, co USB jádro předává USB ovladačům.
Každé zařízení je vázáno konfigurací, které je předáváno v deskriptorech.
Linuxové jádro popisuje konfigurace ve struktuře {\em usb\_host\_config} a celé USB zařízení strukturou {\em usb\_device}.
Jedno USB zařízení však může mít konfigurací více.
Konfigurace se mohou v průběhu práce zařízení měnit.
Linuxové jádro ale nemůže obsluhovat více konfigurací v jeden čas.


Ovladače USB zařízení  obyčejně přepisují data z {\em usb\_interaface} do {\em usb\_device}.
Samotné struktury {\em usb\_device} a {\em usb\_interface} jsou zobrazeny v sysfs\ref[SYSFS] jako jednotlivé soubory.
Ukázková cesta ke struktuře {\em usb\_device} reprezentována pomocí sysfs \ref[SYSFS] může vypadat následovně:

\begtt  /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1  \endtt

K výše uvedené cestě k USB zařízení je na řádku níže zvýrazněno USB rozhraní reprezentováno strukturou {\em usb\_interface}.
Tato struktura je pojmenována podle formátu root\_hub-hub\_port:config.interface (pro hlubší stromy je schéma root\_hub-hub\_port-hub\_port:config.interface):

\begtt /sys/devices/pci0000:00/0000:00:09.0/usb2/2-1/2-1:1.0 \endtt

Pro komunikaci se všemi USB zařízeními používá Linuxové jádro USB request block (urb).
Urb je asynchronní typ komunikace, která se používá k posílaní a příjmu dat pro specifický koncový bod USB a specifické USB zařízení.

\label[USBNET]

\secc usbnet

Usbnet je subsystém Linuxového jádra, který umožňuje ovládat USB--síťová zařízení jako je ethernet, DSL, IDSN atd. \ref[USBNET]
Usbnet je obecná USB--síťová nadstavba, která pracuje na různých rychlostech a nad různými protokoly.

Na obrázku níže lze vidět uml diagram důležitých struktur v ovladači AX88772b \ref[umlASIX].

\medskip
\clabel[umlASIX]{Diagram tříd ovladače AX88772b.}
\picw=15cm \cinspic images/driver_asix.pdf
\caption/f Na obrázku můžeme vidět popis vybraných datových struktur v subsystému usbnet.
\medskip

Na obrázku \ref[umlASIX] je znázorněn usbnet obsahuje informace o:
\begitems
*net\_device -- zařízení reprezentující síťové rozhraní
*driver\_info -- rozhraní pro ovladač usbnet zařízení
*usb\_device -- struktura reprezentující zařízení USB
\enditems

\label[SYSFS]

\secc System Filesystem

System FileSystem (Sysfs) je charakteristika Linuxového jádra od verze 2.6, která umožňuje jadernému kódu exportovat informace do uživatelského prostoru za použití paměti VFS\ref[SYSFS].
Hlavním učelem je reprezentovat objekty, jejich atributy a jejich vztahy navzájem.
Většina atributů je reprezentována souborem, který je ve formátu ASCII a obsahuje pouze jednu hodnotu.
Sysfs poskytuje dvě složky:

\begitems
*kernel programming interface -- slouží k exportování a importování položek (viz níže) skrz sysfs do jádra
*user interface -- slouží k zobrazení a manipulaci s těmito položkami (viz níže), které mapuje zpět na objekty v jádře
\enditems

Mapování objektů a atributů můžeme vidět v \ref[SYSFSmap].

\midinsert \clabel[SYSFSmap]{Mapováni objektů a atributů v sysfs.}
\ctable{ll}{
 \hfil  Interní   & Externí  \crl \tskip4pt
        Jaderné objekty    & Složky  \cr
        Atributy objektů     & Soubory  \cr
        Vazby mezi objekty   & Symbolické odkazy  \cr
}
\caption/t  Tabulka převzata z \cite[SYSFS].
\endinsert

V systému lze vidět tato zařízení ve složce {\em /sys/ }.
Složka /sys/ může vypadat následovně:
\begtt
    /sys/
    |-- block
    |-- bus
    |-- class
    |-- devices
    |-- firmware
    |-- module
    ‘-- power
\endtt

Sysfs je reprezentováno v Linuxovém jádře jako struktura {\em kobj}, která obsahuje tři druhy obslužného volání -- na zápis, čtení a na uvolňení.

\label[pouzhw]


\chap Použitý hardware

\label[T20]

\sec Colibri T20

Colibri T20 je počítačový modul postaven na základě NVIDIA Tegra 2 embeded systému na čipu (SOC) \cite[SOC].
SOC modul Tegra 2 je založen na dvoujádrovém procesoru Cortex A9 se symetrickým procesorovým jádrem od firmy ARM s rychlostí okolo 1 Ghz.
Jelikož se jedná o SOC obsahuje tento čip také mnoho bluků jako je například Audio/Video rekordér.
Grafický čip s podporou 2D rendrovaní a 3D pixel a vektor shadrem.

Čip obsahuje periferie popsané na blokovém diagramu na obrázku \ref[SOC].

\medskip
\clabel[SOC]{Colibri T20 blokový diagram.}
\picw=15cm \cinspic images/soc.pdf
\caption/f Obrázek popisuje části integrované na modulu Colibri T20 \cite[SOC].
\medskip

Toradex dodává podporu BSP pro Linuxové jádro 3.1.

%chtelo by to swap Colibri a ARM ci spojit...
\sec NVIDIA Tegra 2

Dvoujadrový procesor ARM Cortex A9 symmetric MPCore je jeden z aplikačních procesorů vyvíjený firmou ARM.
Tento ARM je 32-bitová RISC architektura vyvíjená společností ARM Holding věnující se vývoji procesorových jader.
Tento procesor porporuje out-of-order a spekulativní provádění instrukcí.
Má plnou podporu koherence pamětí pro symetrické procesory.
Toto jádro dosahuje vysokého grafického výkonu, ale také výpočetního výkonu viz. \cite[BENCH].
Procesor též obsahuje jednotku pro výpočty s plovoucí řádovou čárkou.

Popis jádra NVIDIA Tegra 2 můžeme vidět na obrázky níže \ref[TEGRA].

\medskip
\clabel[TEGRA]{Popis jádra NVIDIA Tegra 2.}
\picw=15cm \cinspic images/tegra2.pdf
\caption/f Obrázek popisuje vnitřek proceosru NVIDIA Tegra 2 \cite[TEGRA].
\medskip

\label[ASIX]

\sec Asix AX88772b


AX88772b je zákaznický integrovaný obvod, který umožňuje plug-and-play Fast Ethernet internetové připojení pro zařizení používající stantardizované USB verze 1.1 a verze 2.0 \ref[USB].

Jako jediný z výrobních řad dosahuje v revizi AX88772bli teplotních rozsahů od -40 stupňů Celsia až +85 stupňů Celsia.

AX88772b má modifikovatelnou vícefunkční sběrnici, která umožňuje připojit RMII \ref[RMIIsub] nebo jako Reverse-RMII pro MAC-to-MAC připojení k nějakému mikrokontroléru s ethernet MAC RMII rozhraním.

MAC rozhraní je plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u.

Blokový

%TODO ASIX
\medskip
\clabel[ASIXcip]{Blokový diagram AX88772b.}
\picw=15cm \cinspic images/asix_conn.pdf
\caption/f Obrázek popisuje blokový digram architektury čipu AX88772b od firmy Asix. Obrázek je převzat z \cite[ASIX].
\medskip
%jake umoznuje propojeni po rmii?

Jak je vidět na obrázku \ref[ASIXcip] čip AX88772b obsahuje ethernetovou PHY, která nemůže být aktivní současně s RMII rozhraním.

\label[MARVELL]

\sec Marvell 88E6065

Marvell 88E6065 je 5+1 portový ethernetový přepínač integrovaný na jednom čipu.
Obsahuje  pět portů na fyzicke vrstvě 10~BASE-T/100~BASE-TX, znichž dva porty můžou být použity pro optickou linku 100~BASE-FX.
Šestým portem je nezávyslí Fast ethernet MAC.
Zařízení má high-speed, non-blocking čtyřúrovňový QoS.
PHY podporuje plag-n-play s možností Auto-Crossoer, Auto-polarity a Auto-nogotiation.
Zařízení dále odporuje 64 z 4096 802.1Q WLAN s 3 úrovňovou ochranou.
Má dva RMII/MII/SNI rozhraní, která mohou být připojena k menežovacímu rozhraní nebo ke kontroleru s integrovanou MAC.

MAC a PHY rozhraní jsou plně kompatibilní se standardy IEEE~802.3, IEEE~802.3u a IEEE~802.3x.
Zařízení může být konfigurováno přez STA nebo může nastavení načítat z EEPROM paměti.

Výjmečně se může Marvell 88E6065 využívat podpory pro směrovače a výchozí brány.
%jake umoznuje porjojeni RMII
\medskip
\clabel[MARVELL6060]{Blokový diagram 88E6060.}
\picw=15cm \cinspic images/6060conn.pdf
\caption/f Obrázek popisuje blokový zapojení čipu 88E6060 od firmy Marvell, která je velmi podobná 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

\label[SWITCH]

\sec Deska menežovatelného přepínače


Desku menežovatelného přepínače je vyrobena firmou Retia a.s. 
\fnote{Firma zabívající se elektronickými vojeskými systémy, zaznomovými zařízeními a lokalizačních a bezpočnostních systémů. \url{www.retia.cz}}
na základě jejich návrhu a zapojení popsaných v přílohách \ref[zapojeni] \ref[zapojeni2] \ref[zapojeni3].
A zjednodušené schéma můžete vidět na obrázky \ref[deska].

\medskip
\clabel[deska]{Blokové schéma desky menežovatelného přepínače.}
\picw=15cm \cinspic images/diagdeska.pdf
\caption/f Obrázek popisuje blokový zapojení desky menežovatelného přepínače.
\medskip

Menežovatelný přepínače umožňuje konfiguraci ethernetoveho přepínače za pomoci USB ethernet kontroléru AX88772b od firmy Asix \ref[ASIX], ke kterému je připojena externí pamět eeprom M93-C66.
Tento kontrolér je připojen RMII rozhraním k čipu Marvell 88E6065 \ref[MARVELL], tak jak můžete vidět na obrázku níže \ref[MARVELL6065rmii].


\medskip
\clabel[MARVELL6065rmii]{Zapojení RMII.}
\picw=10cm \cinspic images/rmii.pdf
\caption/f Obrázek popisuje připojení RMII rozhraní zařízení 88E6065. Obrázek je převzat z \cite[MARVELL].
\medskip

Marvell 88E6065 je ethernetový přepínač, který má k sobě kromě zmíněného RMII portu připojeno pět ethernetových portů a taktéž je kněmu připojena externí pamět eeprom.
Oba tyto čipy mají též vlastní krystal na frekvenci 25~Mhz.
Deska je taktéž osazena regulátorem napětí a přepínači pro různá nastavení MII rozhraní(K3 a K2), resetování(K5) a externího vzbuzení(K4) jak můžete vidět na v příloze \ref[zapojeniXXX].

\label[impl]

\chap Implementace

Tato kapitola rozebírá update systému pro modul Colibri T20 \ref[T20], který byl zapotřebí pro další implementaci ovladačů pro aktuální Linuxové jádro.
Dále se zabívá způsobem oživení desky \ref[SWITCH] a následným popisem tvorby ovladače pro menežovatelný přepínač.

Vývoj probíhal na vývojovém kitu s modulem Colibri T20.
Pro vývoj ovladače bylo zvoleno jádro z upstreamové větve kernelu
\fnote{Linuxové jádro je možná stáhnout na \url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git}}
konkrétně se začlo s verzí 3.17 a následně došlo až k přeportování ovladače na verzi 3.19.

\label[UPSTREAM]

\sec Portace upstreamové linuxové jádro a zavaděče

Portace upstramového jádra vyžaduje několik nástrojů a programů pro překlad kódu, linkování a přehrátí paměti.

\secc U-Boot

V první řadě je potřeba naistalovat zavaděč, který se postará o zavedení Linuxové jádra.
Pro tento úkol byl zvolen U-Boot, který používá již výrobce desky Colibri T20.
Jen byla zvolena jeho novejší verze
\fnote{U-Boot je možný stáhnout z repozitáře \url{git://git.denx.de/u-boot.git}}.

%TODO XXX odkaz 

V první řadě je potřeba stáhnout a zkompilovat nejnovější zavaděč \cite[UPLINUXT20].
Konfigurační soubor byl zvolen {\em colibri\_t20\_iris\_config}, který odpovídá modulu Colibri T20 s vývojovou deskou iris.

\begtt
$ git clone git://git.denx.de/u-boot.git
$ export CROSS_COMPILE=~/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
$ export ARCH=arm
$ make colibri_t20_iris_config
$ make -j8
\endtt

Dalším krokem je stáhnout nástroje, které slouží k vytvoření cílového binarního souboru.

\begtt
$ git clone https://github.com/NVIDIA/cbootimage-configs.git
$ cbootimage -gbct -t20
		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.bct.cfg
 		colibri-t20_512_v12_nand.bct
$ cp ../u-boot/u-boot-dtb-tegra.bin u-boot.bin
$ cbootimage -t20
 		tegra20/toradex/colibri-t20/colibri-t20_512_v12_nand.img.cfg
 		colibri-t20_512_v12_nand.img
\endtt

Poté nabootujeme z diskového souboru příkazem:

\begtt
$ tegrarcm --bct colibri-t20_512_v12_nand.bct --loadaddr=0x00108000
 		--bootloader=../u-boot/u-boot-dtb-tegra.bin
\endtt

Poté co nabootujem naš obraz. Můžeme vidět jak na konzoly se objeví náš zavaděč.
A pomocí USB-ethernetového kontroléru nahrajem obraz bootloaderu do paměti modulu.

\begtt
Tegra20 (Colibri) # usb start
(Re)start USB...
USB1: USB EHCI 1.00
scanning bus 1 for devices... 1 USB Device(s) found
USB2: USB EHCI 1.00
scanning bus 2 for devices... 2 USB Device(s) found
 scanning usb for storage devices... 0 Storage Device(s) found
 scanning usb for ethernet devices... 1 Ethernet Device(s) found
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot 0x02100000 colibri-t20_512_v12_nand.img
Waiting for Ethernet connection... done.
TFTP from server 192.168.80.3; our IP address is 192.168.80.90
Filename 'colibri-t20_512_v12_nand.img'.
Load address: 0x02100000
Loading: #################################
         3.6 MiB/s
done
Bytes transferred = 729088 (b2000 hex)
\endtt

Po nahrátí obrazu do paměti přepíšem minulý zavaděč současným.
Délka přeneseného obrazu je 0xb2000 viz. výše.
Tato hodnota je potřeba k přepsaní NAND paměti.

\begtt
Tegra20 (Colibri) # nand erase.chip

NAND erase.chip: device 0 whole chip
Erasing at 0x3ffc0000 -- 100% complete.
OK
Tegra20 (Colibri) # nand write 0x02100000 0 0xb2000

NAND write: device 0 offset 0x0, size 0x95000
 577536 bytes written: OK
\endtt

Nyní nám při resetu zařízení naběhne upstramový U-Boot, který nemůže nalézt žádné jádro.
To přidáme v další sekce \ref[LINUXkernel].

\label[LINUXkernel]

\secc Linuxové jádro

V dalším krokem byla instalace současné verze jádra, která byla nutná k vývoji ovladačů a komunikací s linuxovou komunitou.
Jelokož upstreamové jádro nepodporuje NAND paměť načítání nového jádro probýhalo přez síť \cite[UPLINUXT20].

V první řadě je potřeba stáhnout a zkompilovat nejnovější verzi Linuxového jádra \cite[UPLINUXT20].
Použije se konfigurace, {\em tegra\_defconfig}, která v jádře vybere moduly a ovladače pro běh jádra.

\begtt
$ git clone git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
$ export LOADADDR=0x408000
$ export ARCH=arm
$ export CROSS_COMPILE=/PATH/gcc-linaro/bin/arm-linux-gnueabihf-
$ make tegra_defconfig
$ make -j8 uImage
\endtt

Po přeložení jádra můžeme nahrat obraz jádra a přeloženého DT
\fnote{Device Tree popisuje hardwarového zapojení modulu.}
do RAM paměti modulu za pomoci USB-ethernetového kontroléru v kozoly zavaděče U-Boot následujícími přikazy:

\begtt
Tegra20 (Colibri) # usb start
Tegra20 (Colibri) # setenv ipaddr 192.168.80.90
Tegra20 (Colibri) # setenv serverip 192.168.80.3
Tegra20 (Colibri) # tftpboot ${kernel_addr_r} uImage
Tegra20 (Colibri) # tftpboot ${fdt_addr_r} tegra20-iris-512.dtb
\endtt
%Load address: 0x1000000 kernel
%Load address: 0x2000000 dbt
Po nahrátí obrazů nastavíme parametry pro Linuxové jádro
\fnote{\url{https://www.kernel.org/doc/Documentation/kernel-parameters.txt}}.
V našem případě nastavení konzole, port a rychlost. Nastvaní oddílů s distribucí, jeho filesystémem a typem.
Poté můžeme náš kernel spustit.

\begtt
Tegra20 (Colibri) # set bootargs console=ttyS0,115200n8 earlyprintk
		root=/dev/mmcblk0p1 rootfstype=ext2 rw rootdelay=1
Tegra20 (Colibri) # bootm ${kernel_addr_r} - ${fdt_addr_r}
\endtt

Pokud máme na SD kartě distibuci tak nám ji naše jádro zavede.


\sec Oživení desky

Oživení desky začalo s testovaním USB kontroleru Asix AX88772b \ref[oAX].
Po oživení komunikačního rozhraní se pokračovalo s laděním ethernetového přepínače 88E6065 \ref[oMV].
Posledni casti bylo testovani ethernetovych portu systému celého.
Přičemž bylo objeveno několik chyb v návrhu desky. Která byla na základě mojich připomínek opravena(XXX to zaveru).

\label[oAX]

\secc Oživení Asix AX88772b

Při oživování USB kontroléru byla objevena zavada na jeho připojení na desce.
Tato závada se projevovala chybnou komunikací na USB sběrnici, která byla objevena při použití modulu Colibri T20.
Tu to chybnou komunikaci můžete vidět na obrázku \ref[usbbuserr].
Kde je znatelně vidět, že pakety, které dochazili hostovskému zařízení příjímal poškozené.

\medskip
\clabel[usbbuserr]{Chybná komunikace na USB sběrnici.}
\picw=15cm \cinspic images/wrong_com_wire.pdf
\caption/f Na obrázku můžeme vidět chybnou komunikaci na usb sběrnici mezi PC a USB kontrolerem Asix AX88772b zaviněnou nepřipojením blokovacího kondenzatoru.
\medskip

Po úpravě zapojení kontroléru. Začal USB kontroler odpovídat na dotazy současného ovladače v operačním systému Linux.


\medskip
\clabel[ASIXRMII]{Chybna komunikace na usb sbernici.}
\picw=15cm \cinspic images/asix_rmii.pdf
\caption/f Na obrázku .
\medskip

Na obrázku \ref[ASIXRMII] je možné vidět, že AX88772b nemůže komunikovat po rozhraních PHY a RMII zároveň.
Zápisem do registru XXX se aktivuje jeden z těchto dvou rozhraní a spojkou K2 \ref[zapojeni3] se nastavil AX88772b do režimu MAC.

Dále bylo potřeba nastavit vhodne chovani čipu Asix, aby začal fungovat rozhraní RMII, které je blíže popsané v \ref[ZPRAC].

\label[oMV]

\secc Oživení ethernetového přepínače Marvell 88E6065

K oživení a stabilnímu chování ethernetového přepínače Marvell 88E6065 bylo zapotřebí aktivovat RMII rozhraní a provést několik zásahů do zapojení čipu na desce.
Taktéž bylo zapotřebí funkční komunikaci přez Asix AX88772b \ref[oAX], terý na základě USB příkazů posílá zprávy na RMII rozhraní.
Též bylo potřeba vyřešit, kdo bude v jakém módu, nakonec se zvolilo připojení MAC-MAC. Ve kterém hodiny pro MDIO vysílá zařízení AX88772b a hodiny o frekvenci 50 Mhz pro RMII zařízení Marvell. Zapojení vypadá tak jak můžete vidět na obrázku \ref[MARVELL6065rmii].

Byli doplněny chybějící blokovací kondenzátory.
A z důvodu nestabilních vstupních hodnot na čipu byl doplněn kondenzátor, který zařízení vyresotovával čip po dobu časové konstanty RC po připojení přepínače k napájení.
A na základě mojich požadavků byli přidány pull-up a pull-down rezistory pro správné a deterministické chováni přepínače.
\begitems
\enditems

\sec Návrh ovladače

Návrh ovladače byl založen na propojení ovladače pro Asix AX88772b a subsystému DSA \ref[DSA].

Celý ovladač by měl fungovat, tak že při připojení USB zařízení se zavede ovladač pro zařízení AX88772b.
Ta inicializuje tento ovladač do standardního stavu na zákaldě funkce usb\_probe(), která na základě ID produktu a výrobce vybere správný ovladač.
V našem případě je to ax88772b\_info, která je instancí stuktury driver\_info.
Tato struktura je v současné době naimplemntováno v aktuální verzi Linuxové jádra.
To je takové, že ovladač aktivuje PHY interface a vytvoří rozhraní pro ethernetovou komunikaci přez net\_device strukturu a ethtool\_ops a net\_device\_ops funce.
Doplní se funkce, která vytvoří node v sysfs\ref[SYSFS].
Za pomoci obslužné rutiny nodu v sysfs spojí usbnet zařízení s DSA subsystémem.
Tato rutiny předá DSA subsystému instance struktur net\_device, mii\_bus a o potrech switche ve struture dsa\_platform\_data. Všechny tyto instance nebo jejich reference nese platform\_device. Tyto struktury můžeme vidět v \ref[umlDSA].

Za pomocí těchto dat, se v DSA subsystému aktualizuje celý ovladač.
Ten si nejde potřebný ovladač ke konkrétnímu přepínači a pro každý port vytvoří vlastní síťové rozhraní.

Proces uvolňování je rešen při funcí XXX ta uvolňuje celý subsystém DSA a na něm zavislé instance.
Tato funce, nejdrive vyvolá uvolnění v subsytému DSA a poté uvolní časti v AX88772b.

\label[ZPRAC]

\sec Zpracování

Sekce zpracování popisuje jednotlivé časti ovladače.

Jelikož nebyl ovladač pro zařízení Asix AX88772b připraven na připojení RMII rozhraní.
Bylo potřeba nastavit tento interface jako aktivní, ten však nemůže být aktivní současně s ethernet PHY, která je taktéž integrovaná na čipu jak je vidět \ref[ASIXRMII].
Implementace oladače je popsána v \ref[asixdri].

Dále bylo potřeba upravit subsystém DSA, aby podporoval hotswap zařízení, konkrétně jeho odhlašovnání a uvolňování. Popsaný v \ref[dsadri].

Poslední částí bylo napsat samotný ovladač pro Marvell 88E6065, který řeší veškerou funkčnost samotného přepínače. Popsaném v \ref[mvdri].

\label[asixdri]

\secc Ovladač zařízení Asix AX88772b

Asix AX88772b má již podporu v Linuxovém jádře a však pouze na jedno z jeho rozhraní.
Tím rozhraním je ethernet PHY \ref[ASIX]. Bylo potřeba doplnit ovladač o aktivaci RMII rozhraní.
A byla zvolena možnost, že aktivace RMII rozhraní proběhne přez zápis do souboru {\em dsa\_bind}, áež je součástí file systému sysfs, a je umístěn ve složce USB zařízení.
Po zapsání do tohoto souboru se vyvolá obslužná rutina objektu {\em usb\_dsa\_store() }, která je nainicializována strukturou  kobj. Tato rutina převezme informace o tom, kdo ji zavolal a  vyvolá {\em dsa\_bind()}
Ta nastaví příslušné registry pro aktivování RMII rozhraní, zapsaním do příslušných registrů.
Nadále tato rutina též otestuje zdali, je k USB kontroléru připojeno zařízení Marvell 88E6065, dle standardizovánému registrovému prostoru \ref[miireg].
Konkrétně vyčtením z třetího registru z \ref[miireg], která obsahuje ID a revizy zařízení.
Tato část obslužné rutiny též vyplní strukturu {\em asix\_common\_private}, které v současné verzi kompatibilní s jadrem verze 3.19 vypadá následovně:

\begtt
struct asix_common_private {
   struct asix_rx_fixup_info rx_fixup_info;
#ifdef CONFIG_NET_DSA
   struct kobject kobj;
   struct mii_bus *mdio;
   bool use_embphy;
   bool dsa_up;
   struct usbnet *dev;
   struct platform_device *pdev;
#endif
}
\endtt

%Ve verzi linuxového jádra 3.19 subsystém DSA byl upraven a nevyžaduje strukturu {\em mii\_bus} a byl odstraněn a je nahrazena  strukturou {\em platform\_device}, aby se vyhnulo většině změn v subsystému DSA dle připomýnky v mailing listu \ref[ML].
Starší verze této struktury neobsahovala platform\_device, ten byl doplněn na základě připomýnky z komunikace mezi mnou a vývojáři Linuxového jádra \ref[ML].
A proto ovladač zařízení Asix AX88772b byl doplněn o funkci {\em dsa\_create\_pdev}, která zajistí naplnění struktury {\em platform\_device}.
Tato struktura se vytváří při po kontrole zařízení ve funkci {\em dsa\_bind}.

Po naplnění základních struktur ovladač Asix AX88772b zavolá {\em dsa\_probe\_netdevice()}, který vytvoří softwarové rozhrání přepínače. Změna DSA subsystému je popsaná v \ref[dsadri].

\label[dsadri]

\secc Úprava subsystému DSA

Subsystém DSA byl rozšířen o veřejnou funkci {\em dsa\_probe\_netdevice()}, která vytváří softwarové rozhraní pro přepínač.
Každý port přepínače je reprezentován vlastním ethernetovým rozhraním net\_device \ref[NETDEV], které mají společného rodiče stejného typu.

Bylo potřeba odloučit DSA od platform\_driveru což následně zapříčiňuje rozšíření dsa\_switch\_driver \ref[mvdri].

Větší rozsah změn čekala uvolňovací část ovladače.
Jelikož se nepředpokladá, že by se tento ovladač někdy uvolňoval, které pline z debaty na \cite[ML].
Tato funce nebyla dodělána a proto byla upravena {\em dsa\_destroy()}, která v současné verzi podporuje uvolnění všech portů a interních struktur DSA ovladače jako je struktura {\em dsa\_switch a dsa\_switch\_tree}.


\label[mvdri]

\secc Ovladač zařízení Marvell 88E6065

Bylo zapotřebí vytvořit ovladač pro zařízení 88E6065 od firmy Marvell, který nemá žádnou podporu v Linuxovém jádře.

Tento ovladač je instancí dsa\_switch\_driver jak je možné vidět na obrázku \ref[umlDSA].
Struktura dsa\_switch\_driver obsahuje metody, které zajišťují nainicializování, uvolňení a nastavění switche jako celku a jednotlivých portů.



\sec Spojení jednotlivých ovladačů


Všechny ovladače dělají svou partikulární část. Na připojení USB a příjmutí ID se zavede ovladač AX88772b, který aktivuje PHY. Po zapisu do souboru dsa\_bind se v adresáři přislušného USB zařízení se aktivuje druhé rozhraní ovladače a nainicializuje DSA strukturu. Tato struktura vytvoří dostatek ethernetových rozhraní a připojí příslušný ovladač pro přepínací obvod.

Nyní na základě příkazů pro ethtool můžeme komunikovat s ovladačem skrz uživatelský prostor.

\sec Odezva komunity

Odezva komunity byla velmi rychlá po odeslaní RFC patche
\fnote{\url{http://lists.openwall.net/netdev/2015/04/21/20}}.
se mi dostalo odpovědi během pouhých pár hodin.
Kde Andrew Lunn se vyjádřil k mému nápadu a navrhl nějaké optimalizace k mému řešení.
Také se strhla debata o možnostech DSA, že DSA není připravené pro podporu hotswap zařízení.
A pravděpodobně tato změna nenastane ani v příštích verzích Linuxového jádra.
Další věcí o které padla řeč, je že se pravděpodobně celý subsystém DSA přepíše.

\chap Otestujte implementované řešení zejména s ohledem na propustnost sítě a stabilitu

Tato kapitola se zabiva

\begtt
[11.046] Unable to handle kernel paging request at Virtual Addr 6b6b6b77
[11.053] pgd = c0004000
[11.055] [6b6b6b77] *pgd=00000000
[11.059] Internal error: Oops: 5 [#1] PREEMPT SMP ARM
[11.064] Modules linked in:
[11.067] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.19.0 #298
[11.075] Hardware name: NVIDIA Tegra SoC (Flattened Device Tree)
[11.082] task: c08ba2a8 ti: c08ae000 task.ti: c08ae000
[11.087] PC is at get_next_timer_interrupt+0xa0/0x294
[11.092] LR is at get_next_timer_interrupt+0x60/0x294
[11.098] pc : [<c006f474>]    lr : [<c006f434>]    psr: 90000093
[11.098] sp : c08aff00  ip : 6b6b6b6b  fp : 00000000
[11.109] r10: c0927540  r9 : ffff8f21  r8 : ffff8f20
[11.114] r7 : 00000000  r6 : 3fff8f1f  r5 : ffff8f20  r4 : ffff8f17
[11.121] r3 : 6b6b6b6b  r2 : 00000021  r1 : 00000023  r0 : c0927674
[11.127] Flags: NzcV IRQs off FIQs on Mode SVC_32 ISA ARM Segment kernel
[11.135] Control: 10c5387d  Table: 1ac0404a  DAC: 00000015
[11.140] Process swapper/0 (pid: 0, stack limit = 0xc08ae238)
[11.146] Stack: (0xc08aff00 to 0xc08b0000)
[11.151] ff00: c08affa4 c060ecc0 0000001d c00625f0
    fe44010c 0000000d c08aff40 c08b7154
[11.159] ff20: 755c2278 00000002 c08ac640 60000000
    00000185 dbbb4280 00000000 ffff8f20
[11.216] [<c006f474>] (get_next_timer_interrupt)
    from [<c007e34c>] (__tick_nohz_idle_enter+0x2d4/0x41c)
[11.226] [<c007e34c>] (__tick_nohz_idle_enter)
    from [<c007e4e0>] (tick_nohz_idle_enter+0x30/0x6c)
[11.235] [<c007e4e0>] (tick_nohz_idle_enter)
    from [<c00552c4>] (cpu_startup_entry+0x18/0x278)
[11.244] [<c00552c4>] (cpu_startup_entry)
    from [<c0868c0c>] (start_kernel+0x360/0x3cc)
\endtt

\sec propustnost

\sec porovnani s jinym eth interfacem

\sec Konfigurace

Konfigurace přepínače probíhá skr konfiguraci nástroji ifconfig a vconfig

co se testuje a jak se testuje(co pisu za prikazy) -> vysledky

\sec logterm

\chap Zaver

funguje, odezva, linuxova komunita, dosazene vysledky, vykon
MII,RMII,GMII,RGMII,SGMII,QGMII,XAUI
